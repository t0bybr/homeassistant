# =========================================================
# Jalousie Blueprint ‚Äì LOGO/MQTT Tastersteuerung mit State Machine
# =========================================================
# Features:
# - State Machine: Klare Zustandsverwaltung (idle, moving_user, moving_automation, etc.)
# - Taster Hoch/Runter: Kurz-/Langdruck mit Sofort-Stop
# - Tilt-System: Automatisches Tracking + intelligente Drift-Vermeidung
# - Sequence-ID: Verhindert Endlosschleifen bei Multi-Step-Operationen
# - Wind-Sync & Position-Backup: Robuste LOGO-Integration
#
# State Machine:
# - idle: Bereit f√ºr neue Befehle
# - moving_user: Manuelle Tasterbedienung
# - moving_automation: Automatische Fahrt (Zeit, Szene)
# - moving_wind: Wind-Schutzfahrt
# - moving_tilt: Einfache Tilt-Anpassung
# - adjusting_tilt_ref: Multi-Step Tilt mit Referenzpunkt
# - recovering_position: LOGO-Neustart, Position-Sync
#
# Tilt-System:
# - tilt_current: Wird automatisch getrackt (0% = vertikal, 100% = horizontal)
# - tilt_target: Zielneigung (Standard: 75%, konfigurierbar)
# - tilt_enabled: Toggle via 2√ó Hoch-Taste
# - Drift-Vermeidung: Referenz-Methode bei Bewegungen < min_motor_ticks
#
# MQTT Signale:
# - logo/register/set/<target>: Zielposition in Ticks (oder 10000 = Best√§tigung)
# - logo/register32/set/<counter>: Position-Counter Backup
# - logo/coil/set/<coil>: Motor an/aus (ON/OFF)
#
# LOGO Sensoren:
# - position_ticks_sensor: Aktuelle Position (0..max_travel_ticks)
# - movement_status_sensor: 0=closed, 1=idle/open, 2=closing, 3=opening
#
# Kalibrierung (im use_blueprint angeben):
# - max_travel_ticks: Maximaler Fahrweg in Ticks (gemessen)
# - tilt_ticks_close: Ticks von horizontal zu vertikal (z.B. 14)
# - tilt_ticks_open: Ticks von vertikal zu horizontal (z.B. 15)
# - min_motor_ticks: Minimale Bewegung die Motor ausf√ºhrt (typ. 5)
# =========================================================

blueprint:
  name: Jalousie ‚Äì LOGO/MQTT mit State Machine & Tilt
  description: >
    Intelligente Jalousie-Steuerung mit State Machine, automatischem Tilt-Tracking
    und Drift-Vermeidung. Features: Kurz/Langdruck, 2√ó Hoch = Tilt Toggle,
    Sequence-ID gegen Endlosschleifen, Wind-Sync, Position-Backup.
  domain: automation
  input:
    # Identifikation
    name:
      name: "Raum-Slug (z. B. wohnzimmer_west)"
      selector: { text: { multiline: false } }
    floor:
      name: "Stockwerk-Slug (z. B. 0)"
      selector: { text: { multiline: false } }

    # Taster
    up_button_entity_id:
      name: "Taster Hoch (binary_sensor)"
      selector: { entity: { filter: [{ domain: binary_sensor }] } }
    down_button_entity_id:
      name: "Taster Runter (binary_sensor)"
      selector: { entity: { filter: [{ domain: binary_sensor }] } }

    # Cover
    cover_entity:
      name: "Cover-Entit√§t (Template-Cover)"
      selector: { entity: { filter: [{ domain: cover }] } }

    # Tilt-Entit√§ten (f√ºr Trigger)
    tilt_enabled_entity_id:
      name: "Tilt Enabled Entity (input_boolean)"
      selector: { entity: { filter: [{ domain: input_boolean }] } }

    # Tilt-Konfiguration
    tilt_target_default:
      name: "Standard-Neigung beim Toggle (0-100%)"
      selector: { number: { min: 0, max: 100, step: 5, mode: slider } }
      default: 75

    tilt_position_threshold_pct:
      name: "Maximale Position f√ºr Tilt (%)"
      description: "Tilt nur verf√ºgbar wenn Position < dieser Wert"
      selector: { number: { min: 0, max: 100, step: 5, mode: slider } }
      default: 80

    # LOGO/MQTT Parameter
    coil_up:
      name: "LOGO Coil: hoch"
      selector: { number: { min: 1, max: 9999, mode: box } }
    coil_down:
      name: "LOGO Coil: runter"
      selector: { number: { min: 1, max: 9999, mode: box } }
    register_target:
      name: "LOGO Register: Zielposition (Ticks)"
      selector: { number: { min: 1, max: 9999, mode: box } }
    register_max_ticks_limit:
      name: "LOGO Register: max. Fahrweg/-dauer (Ticks-Limit)"
      selector: { number: { min: 1, max: 9999, mode: box } }
    register_counter:
      name: "LOGO Register: Counter/Position (f√ºr Backup)"
      selector: { number: { min: 1, max: 9999, mode: box } }

    # Skalierung & Sensoren
    max_travel_ticks:
      name: "Max. Fahrweg in Ticks (100%)"
      selector: { number: { min: 1, max: 5000, mode: box } }
    position_ticks_sensor_entity_id:
      name: "Positionssensor in Ticks (0..max_travel_ticks)"
      selector: { entity: { filter: [{ domain: sensor }] } }
    movement_status_sensor_entity_id:
      name: "Statussensor (0=closed,1=idle/open,2=closing,3=opening)"
      selector: { entity: { filter: [{ domain: sensor }] } }

mode: parallel
max: 10

# -----------------------------
# TRIGGER
# -----------------------------
trigger:
  # === HAUPTAUTOMATION ===

  # Taster
  - trigger: state
    entity_id: !input up_button_entity_id
    from: "off"
    to: "on"
    id: button_up

  - trigger: state
    entity_id: !input down_button_entity_id
    from: "off"
    to: "on"
    id: button_down

  # HA-Start ‚Üí Limit setzen
  - trigger: homeassistant
    event: start
    id: ha_start

  # Automations-Reload ‚Üí Limit erneut setzen
  - trigger: event
    event_type: automation_reloaded
    id: automation_reload

  # Statuswechsel (Fahrt beginnt/endet)
  - trigger: state
    entity_id: !input movement_status_sensor_entity_id
    id: status_change

  # Wind-Sensor
  - trigger: state
    entity_id: binary_sensor.mosquitto_broker_mqtt_logo_coil_20
    id: wind_change

  # === TILT-CONTROLLER ===

  # Tilt manuell togglet (2√ó Hoch)
  - trigger: state
    entity_id: !input tilt_enabled_entity_id
    id: tilt_toggle

  # Fahrt endet (f√ºr Auto-Korrektur)
  - trigger: state
    entity_id: !input movement_status_sensor_entity_id
    from:
      - "2"
      - "3"
    to:
      - "0"
      - "1"
    id: movement_ended_tilt

  # Position √ºberschreitet 80% (Auto-Disable)
  - trigger: numeric_state
    entity_id: !input position_ticks_sensor_entity_id
    above: 441  # 80% von 552 Ticks (wird pro Jalousie konfiguriert)
    id: position_high_tilt

# -----------------------------
# VARIABLEN (sprechende Namen)
# -----------------------------
variables:
  # Slugs
  var_floor_slug: !input floor
  var_room_slug: !input name

  # Entit√§ten, die als Inputs kommen
  var_cover_entity_id: !input cover_entity

  # Abgeleitete Entit√§ten (m√ºssen zu deinen Helpers passen!)
  var_state_entity_id: "input_select.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_state"
  var_sequence_id_entity_id: "input_text.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_sequence_id"

  var_counting_flag_entity_id: "input_boolean.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_counting"
  var_click_counter_entity_id: "counter.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_clicks"
  var_last_direction_text_entity_id: "input_text.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_last_direction_text"

  # Letzter Bewegungsstatus (input_number, 2=closing, 3=opening)
  var_last_moving_state_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_last_moving_state"
  var_position_backup_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_position_backup"
  var_movement_start_ticks_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_movement_start_ticks"

  # Tilt-Entit√§ten
  var_tilt_enabled_entity_id: "input_boolean.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_enabled"
  var_tilt_lock_entity_id: "input_boolean.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_lock"
  var_tilt_current_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_current"
  var_tilt_target_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_target"
  var_tilt_ticks_close_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_ticks_close"
  var_tilt_ticks_open_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_ticks_open"
  var_min_motor_ticks_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_min_motor_ticks"

  # UI-/Helper (sichtbar in HA) ‚Äì **an deine Namen angepasst**
  var_target_register_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_logo_register_target"
  var_max_travel_ticks_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_max_travel_ticks"
  var_coil_up_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_logo_coil_up"
  var_coil_down_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_logo_coil_down"

  # Inputs aus Blueprint
  var_status_sensor_entity_id: !input movement_status_sensor_entity_id
  var_up_button_entity_id: !input up_button_entity_id
  var_down_button_entity_id: !input down_button_entity_id
  var_logo_register_target: !input register_target
  var_logo_register_max_limit: !input register_max_ticks_limit
  var_logo_register_counter: !input register_counter
  var_max_travel_ticks_value: !input max_travel_ticks
  var_position_ticks_sensor_entity_id: !input position_ticks_sensor_entity_id
  var_coil_up_value: !input coil_up
  var_coil_down_value: !input coil_down

  # Tilt-Konfiguration (aus Inputs)
  var_tilt_target_default: !input tilt_target_default
  var_tilt_position_threshold_pct: !input tilt_position_threshold_pct

# -----------------------------
# ACTIONS
# -----------------------------
action:
  - choose:
      # Wind-Ende Sync
      - conditions: >
          {{
            trigger.entity_id == 'binary_sensor.mosquitto_broker_mqtt_logo_coil_20'
            and trigger.from_state.state == 'on'
            and trigger.to_state.state == 'off'
          }}
        sequence:
          - action: mqtt.publish
            data:
              topic: "logo/register32/set/{{ var_logo_register_counter }}"
              payload: "{{ states(var_max_travel_ticks_value) | int }}"

      # Wenn die Logo neu startet und die Positionswerte nicht mehr passen
      - conditions: >
          {{
            trigger.entity_id == var_position_ticks_sensor_entity_id
            and (trigger.to_state.state is not none)
            and (trigger.to_state.state | int in [0])
            and (states(var_position_backup_number_entity_id) | int(-1) not in [0])
          }}
        sequence:
          - action: mqtt.publish
            data:
              topic: "logo/register32/set/{{ var_logo_register_counter }}"
              payload: "{{ states(var_position_backup_number_entity_id) | int }}"

      # Positionswert in Backup schreiben
      - conditions: >
          {{
            trigger.entity_id == var_position_ticks_sensor_entity_id
            and (trigger.to_state.state is not none)
          }}
        sequence:
          - action: input_number.set_value
            target:
              entity_id: "{{ var_position_backup_number_entity_id }}"
            data:
              value: "{{ states(var_position_ticks_sensor_entity_id) | int }}"

      # Fahrt startet: 0/1 ‚Üí 2/3 ‚Üí Tilt-Current aktualisieren (nur wenn nicht Tilt-Operation)
      # WICHTIG: Doppelter Schutz gegen Race Conditions:
      # 1. State darf nicht moving_tilt/adjusting_tilt_ref sein
      # 2. sequence_id muss leer sein (keine Tilt-Sequenz aktiv)
      - conditions: >
          {{
            trigger.entity_id == var_status_sensor_entity_id
            and (trigger.from_state is not none)
            and (trigger.from_state.state | int(0)) in [0,1]
            and (trigger.to_state.state   | int(0)) in [2,3]
          }}
        sequence:
          # DEBUG: Fahrtstart
          - action: persistent_notification.create
            data:
              title: "‚ñ∂Ô∏è Fahrt startet"
              message: |
                Status: {{ trigger.from_state.state }} ‚Üí {{ trigger.to_state.state }}
                State: {{ states(var_state_entity_id) }}
                Sequence ID: "{{ states(var_sequence_id_entity_id) }}"
                Wird tilt_current gesetzt? {{
                  'JA'
                  if (
                    states(var_state_entity_id) not in ['moving_tilt', 'adjusting_tilt_ref']
                    and (
                      (states(var_sequence_id_entity_id) | string) == ''
                      or (states(var_sequence_id_entity_id) | string).endswith('|done')
                    )
                  )
                  else 'NEIN'
                }}

          # Nur bei normalen Fahrten (NICHT bei Tilt-Fahrten!)
          - if: >
              {{
                states(var_state_entity_id) not in ['moving_tilt', 'adjusting_tilt_ref']
                and (
                  (states(var_sequence_id_entity_id) | string) == ''
                  or (states(var_sequence_id_entity_id) | string).endswith('|done')
                )
              }}
            then:
              # Fallback: Start aus idle ‚Üí als moving_automation markieren
              - if: "{{ states(var_state_entity_id) == 'idle' }}"
                then:
                  - action: input_select.select_option
                    target: { entity_id: "{{ var_state_entity_id }}" }
                    data: { option: "moving_automation" }

              - variables:
                  new_status: "{{ trigger.to_state.state | int(0) }}"
                  current_ticks_start: "{{ states(var_position_ticks_sensor_entity_id) | int(0) }}"

              - action: input_number.set_value
                target: { entity_id: "{{ var_movement_start_ticks_entity_id }}" }
                data: { value: "{{ current_ticks_start }}" }
          - stop: "Movement start handled"

      # Fahrt endet: 2/3 ‚Üí 0/1 ‚Üí best√§tigen + Richtung speichern + Tilt anwenden/deaktivieren
      - conditions: >
          {{
            trigger.entity_id == var_status_sensor_entity_id
            and (trigger.from_state is not none)
            and (trigger.from_state.state | int(0)) in [2,3]
            and (trigger.to_state.state   | int(0)) in [0,1]
          }}
        sequence:
          - delay: "00:00:0.3"
          - choose:
              - conditions: "{{ states(var_status_sensor_entity_id) | int(0) in [0,1] }}"
                sequence:
                  # Best√§tigung an LOGO
                  - action: mqtt.publish
                    data:
                      topic: "logo/register/set/{{ var_logo_register_target }}"
                      payload: "10000"

                  # Letzte Richtung merken
                  - variables:
                      dir_before: "{{ trigger.from_state.state | int(0) }}"
                  - action: input_number.set_value
                    target: { entity_id: "{{ var_last_moving_state_number_entity_id }}" }
                    data: { value: "{{ dir_before }}" }

                  # Position berechnen
                  - variables:
                      current_pct: >
                        {% set ticks = states(var_position_ticks_sensor_entity_id) | int(0) %}
                        {% set max_ticks = var_max_travel_ticks_value | int(1) %}
                        {{ (100.0 * ticks / max_ticks) | round(0) | int }}
                      current_ticks_end: "{{ states(var_position_ticks_sensor_entity_id) | int(0) }}"
                      start_ticks_value: "{{ states(var_movement_start_ticks_entity_id) | int(current_ticks_end) }}"
                      delta_ticks_abs: "{{ (current_ticks_end - start_ticks_value) | abs }}"
                      tilt_ticks_close_value: "{{ states(var_tilt_ticks_close_entity_id) | int(0) }}"
                      tilt_ticks_open_value: "{{ states(var_tilt_ticks_open_entity_id) | int(0) }}"
                      remaining_up_ticks_end: "{{ (var_max_travel_ticks_value | int(1)) - current_ticks_end }}"
                      state_current: "{{ states(var_state_entity_id) }}"

                  # Tilt auto-disable wenn Position >= Schwelle (unabh√§ngig von Richtung)
                  - if: "{{ current_pct >= var_tilt_position_threshold_pct }}"
                    then:
                      - action: input_boolean.turn_off
                        target: { entity_id: "{{ var_tilt_enabled_entity_id }}" }
                      # tilt_current bleibt unver√§ndert

                  # Snap tilt_current nur wenn Fahrt gro√ü genug war
                  - choose:
                      - conditions: >
                          {{
                            dir_before == 2
                            and state_current not in ['moving_tilt', 'adjusting_tilt_ref']
                            and (delta_ticks_abs | int(0)) >= (tilt_ticks_close_value | int(0))
                          }}
                        sequence:
                          - action: input_number.set_value
                            target: { entity_id: "{{ var_tilt_current_entity_id }}" }
                            data: { value: 0 }
                      - conditions: >
                          {{
                            dir_before == 3
                            and state_current not in ['moving_tilt', 'adjusting_tilt_ref']
                            and (delta_ticks_abs | int(0)) >= (tilt_ticks_open_value | int(0))
                          }}
                        sequence:
                          - action: input_number.set_value
                            target: { entity_id: "{{ var_tilt_current_entity_id }}" }
                            data: { value: 100 }

                  # DEBUG: Fahrtende Info
                  - action: persistent_notification.create
                    data:
                      title: "üõë Fahrt beendet"
                      message: |
                        Position: {{ current_pct }}%
                        State: {{ state_current }}
                        Tilt enabled: {{ is_state(var_tilt_enabled_entity_id, 'on') }}
                        Tilt current: {{ states(var_tilt_current_entity_id) }}%
                        Letzte Richtung: {{ dir_before }} (2=runter, 3=hoch)
                        Sequence ID: "{{ states(var_sequence_id_entity_id) }}"
                        Wird apply_tilt aufgerufen? {{
                          'JA'
                          if (
                            current_pct < var_tilt_position_threshold_pct
                            and (
                              (states(var_sequence_id_entity_id) | string) == ''
                              or (states(var_sequence_id_entity_id) | string).endswith('|done')
                            )
                          )
                          else 'NEIN'
                        }}

                  # Tilt anwenden nur bei User/Automation-Fahrten (NICHT bei Tilt-Fahrten!)
                  # Doppelter Schutz:
                  # 1. State darf nicht moving_tilt/adjusting_tilt_ref sein
                  # 2. sequence_id muss leer sein
                  - if: >
                      {{
                        current_pct < var_tilt_position_threshold_pct
                        and is_state(var_tilt_enabled_entity_id, 'on')
                        and (
                          (states(var_sequence_id_entity_id) | string) == ''
                          or (states(var_sequence_id_entity_id) | string).endswith('|done')
                        )
                        and states(var_state_entity_id) not in ['moving_tilt', 'adjusting_tilt_ref']
                      }}
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚úÖ Rufe apply_tilt auf"
                          message: "Script wird jetzt gestartet (State + sequence_id OK)"
                      - action: script.util_blinds_apply_tilt
                        data:
                          floor_slug: "{{ var_floor_slug }}"
                          room_slug: "{{ var_room_slug }}"
                    else:
                      - action: persistent_notification.create
                        data:
                          title: "‚ùå apply_tilt NICHT aufgerufen"
                          message: |
                            Position Check: {{ current_pct }} < {{ var_tilt_position_threshold_pct }} = {{ current_pct < var_tilt_position_threshold_pct }}
                            Tilt enabled: {{ is_state(var_tilt_enabled_entity_id, 'on') }}
                            Sequence ID leer: {{
                              (
                                (states(var_sequence_id_entity_id) | string) == ''
                                or (states(var_sequence_id_entity_id) | string).endswith('|done')
                              )
                            }}
                            State OK: {{ states(var_state_entity_id) not in ['moving_tilt', 'adjusting_tilt_ref'] }} (State: {{ states(var_state_entity_id) }})

                  # State zur√ºck auf idle
                  # WICHTIG: Nur f√ºr User/Automation-Fahrten, NICHT f√ºr Tilt-Fahrten!
                  # Tilt-States (moving_tilt/adjusting_tilt_ref) werden beim N√ÑCHSTEN
                  # Fahrtende auf idle gesetzt (wenn die Tilt-Fahrt wirklich endet)
                  # Sonst: parallel mode Race ‚Üí State zu fr√ºh idle ‚Üí tilt_current √ºberschrieben!
                  - if: "{{ states(var_state_entity_id) in ['moving_user', 'moving_automation'] }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîÑ State Cleanup"
                          message: "State {{ states(var_state_entity_id) }} ‚Üí idle"
                      - action: input_select.select_option
                        target: { entity_id: "{{ var_state_entity_id }}" }
                        data: { option: "idle" }

                  # Tilt-States: Cleanup nur wenn Fahrt wirklich zu Ende (keine aktive Sequenz)
                  - if: >
                      {{
                        states(var_state_entity_id) in ['moving_tilt', 'adjusting_tilt_ref']
                        and (
                          (states(var_sequence_id_entity_id) | string) == ''
                          or (states(var_sequence_id_entity_id) | string).endswith('|done')
                        )
                      }}
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîÑ Tilt State Cleanup (sicher)"
                          message: "State {{ states(var_state_entity_id) }} ‚Üí idle (sequence_id leer)"
                      - action: input_select.select_option
                        target: { entity_id: "{{ var_state_entity_id }}" }
                        data: { option: "idle" }

                  # Sequence-ID endg√ºltig l√∂schen, nachdem das Script "done" signalisiert
                  - if: "{{ (states(var_sequence_id_entity_id) | string).endswith('|done') }}"
                    then:
                      - delay: "00:00:0.2"
                      - action: input_text.set_value
                        target: { entity_id: "{{ var_sequence_id_entity_id }}" }
                        data: { value: "" }
          - stop: "Handled stop + tilt"

      # HA-Start/Reload ‚Üí LOGO-Limit & UI-Helper syncen + State initialisieren
      - conditions: >
          {{
            trigger.platform == 'homeassistant'
            or (
              trigger.platform == 'event'
              and trigger.event.event_type == 'automation_reloaded'
            )
          }}
        sequence:
          - action: mqtt.publish
            data:
              topic: "logo/register/set/{{ var_logo_register_max_limit }}"
              payload: "{{ var_max_travel_ticks_value }}"
          - action: input_number.set_value
            target: { entity_id: "{{ var_max_travel_ticks_number_entity_id }}" }
            data: { value: "{{ var_max_travel_ticks_value }}" }
          - action: input_number.set_value
            target: { entity_id: "{{ var_target_register_number_entity_id }}" }
            data: { value: "{{ var_logo_register_target }}" }
          - action: input_number.set_value
            target: { entity_id: "{{ var_coil_up_number_entity_id }}" }
            data: { value: "{{ var_coil_up_value }}" }
          - action: input_number.set_value
            target: { entity_id: "{{ var_coil_down_number_entity_id }}" }
            data: { value: "{{ var_coil_down_value }}" }
          # State auf idle zur√ºcksetzen
          - action: input_select.select_option
            target: { entity_id: "{{ var_state_entity_id }}" }
            data: { option: "idle" }
          # Sequence ID leeren
          - action: input_text.set_value
            target: { entity_id: "{{ var_sequence_id_entity_id }}" }
            data: { value: "" }
          # Tilt-Target initialisieren wenn noch leer
          - if: "{{ states(var_tilt_target_entity_id) | int(0) == 0 }}"
            then:
              - action: input_number.set_value
                target: { entity_id: "{{ var_tilt_target_entity_id }}" }
                data: { value: "{{ var_tilt_target_default }}" }

      # ========================================
      # TILT-CONTROLLER
      # ========================================

      # Trigger: Tilt manuell togglet (2√ó Hoch)
      - conditions: "{{ trigger.id == 'tilt_toggle' }}"
        sequence:
          # Safety Delay
          - delay: "00:00:01"

          # Variablen sammeln
          - variables:
              tilt_enabled: "{{ is_state(var_tilt_enabled_entity_id, 'on') }}"
              tilt_lock: "{{ is_state(var_tilt_lock_entity_id, 'on') }}"
              status: "{{ states(var_status_sensor_entity_id) | int(0) }}"
              position: "{{ states(var_position_ticks_sensor_entity_id) | int(0) }}"
              position_pct: "{{ (100.0 * position / var_max_travel_ticks_value) | round(0) | int }}"

              # Lookahead: W√ºrde Tilt Position >= 80% machen?
              tilt_current: "{{ states(var_tilt_current_entity_id) | int(0) }}"
              tilt_target: "{{ states(var_tilt_target_entity_id) | int(75) }}"
              delta_pct: "{{ tilt_target - tilt_current }}"
              tilt_ticks_needed: >
                {% if delta_pct > 0 %}
                  {{ (delta_pct / 100.0 * states(var_tilt_ticks_open_entity_id) | int(15)) | round(0) | int }}
                {% elif delta_pct < 0 %}
                  {{ (delta_pct / 100.0 * states(var_tilt_ticks_close_entity_id) | int(14)) | round(0) | int }}
                {% else %}
                  0
                {% endif %}
              position_after_tilt: "{{ position + tilt_ticks_needed }}"
              position_after_tilt_pct: "{{ (100.0 * position_after_tilt / var_max_travel_ticks_value) | round(0) | int }}"

          # DEBUG Notification
          - action: persistent_notification.create
            data:
              title: "üîÑ Tilt Toggle erkannt"
              message: |
                Tilt enabled: {{ tilt_enabled }}
                Status: {{ status }} (1=steht)
                Position: {{ position_pct }}%
                Lock: {{ tilt_lock }}
                Delta: {{ delta_pct }}%
                Ticks needed: {{ tilt_ticks_needed }}
                Position nach Tilt: {{ position_after_tilt_pct }}%

                Checks:
                - Status == 1: {{ status == 1 }}
                - Position < 80%: {{ position_pct < 80 }}
                - Lock OFF: {{ not tilt_lock }}
                - Lookahead < 80%: {{ position_after_tilt_pct < 80 }}

          # Bedingungen pr√ºfen
          - choose:
              # ALLE Bedingungen erf√ºllt ‚Üí apply_tilt
              - conditions: >
                  {{
                    status == 1
                    and position_pct < 80
                    and not tilt_lock
                    and position_after_tilt_pct < 80
                  }}
                sequence:
                  - action: script.util_blinds_apply_tilt
                    data:
                      floor_slug: "{{ var_floor_slug }}"
                      room_slug: "{{ var_room_slug }}"

            # ELSE: Bedingungen nicht erf√ºllt ‚Üí Toggle r√ºckg√§ngig
            default:
              - action: input_boolean.toggle
                target: { entity_id: "{{ var_tilt_enabled_entity_id }}" }

              - action: persistent_notification.create
                data:
                  title: "‚ö†Ô∏è Tilt Toggle abgelehnt"
                  message: |
                    Tilt-Toggle wurde r√ºckg√§ngig gemacht.

                    Gr√ºnde (eines trifft zu):
                    - Jalousie in Bewegung (Status != 1)
                    - Position >= 80%
                    - Tilt-Operation l√§uft bereits (Lock)
                    - Lookahead: Tilt w√ºrde Position >= 80% machen

      # Trigger: Fahrt endet (Auto-Korrektur)
      - conditions: "{{ trigger.id == 'movement_ended_tilt' }}"
        sequence:
          # Safety Delay
          - delay: "00:00:01"

          # Variablen sammeln
          - variables:
              tilt_enabled: "{{ is_state(var_tilt_enabled_entity_id, 'on') }}"
              tilt_lock: "{{ is_state(var_tilt_lock_entity_id, 'on') }}"
              state_current: "{{ states(var_state_entity_id) }}"
              position: "{{ states(var_position_ticks_sensor_entity_id) | int(0) }}"
              position_pct: "{{ (100.0 * position / var_max_travel_ticks_value) | round(0) | int }}"
              dir_before: "{{ trigger.from_state.state | int(0) }}"

          # Auto-Disable Check ZUERST (verhindert unn√∂tigen apply_tilt Aufruf)
          - if: "{{ position_pct >= var_tilt_position_threshold_pct and tilt_enabled }}"
            then:
              - action: input_boolean.turn_off
                target: { entity_id: "{{ var_tilt_enabled_entity_id }}" }
              - action: input_number.set_value
                target: { entity_id: "{{ var_tilt_current_entity_id }}" }
                data: { value: 100 }
              - action: persistent_notification.create
                data:
                  title: "üö´ Auto-Disable"
                  message: "Position {{ position_pct }}% >= 80% ‚Üí Tilt deaktiviert"
              - stop: "Auto-Disable at position >= 80%"

          # tilt_current setzen basierend auf Fahrt-Richtung
          - action: input_number.set_value
            target: { entity_id: "{{ var_tilt_current_entity_id }}" }
            data:
              value: "{{ 0 if dir_before == 2 else 100 }}"

          # Lookahead berechnen
          - variables:
              tilt_current: "{{ states(var_tilt_current_entity_id) | int(0) }}"
              tilt_target: "{{ states(var_tilt_target_entity_id) | int(75) }}"
              delta_pct: "{{ tilt_target - tilt_current }}"
              tilt_ticks_needed: >
                {% if delta_pct > 0 %}
                  {{ (delta_pct / 100.0 * states(var_tilt_ticks_open_entity_id) | int(15)) | round(0) | int }}
                {% elif delta_pct < 0 %}
                  {{ (delta_pct / 100.0 * states(var_tilt_ticks_close_entity_id) | int(14)) | round(0) | int }}
                {% else %}
                  0
                {% endif %}
              position_after_tilt: "{{ position + tilt_ticks_needed }}"
              position_after_tilt_pct: "{{ (100.0 * position_after_tilt / var_max_travel_ticks_value) | round(0) | int }}"

          # DEBUG
          - action: persistent_notification.create
            data:
              title: "üõë Fahrt beendet - Tilt Check"
              message: |
                Tilt enabled: {{ tilt_enabled }}
                Position: {{ position_pct }}%
                State: {{ state_current }}
                Lock: {{ tilt_lock }}
                Current: {{ tilt_current }}% ‚Üí Target: {{ tilt_target }}%
                Delta: {{ delta_pct }}%
                Ticks needed: {{ tilt_ticks_needed }}
                Position nach Tilt: {{ position_after_tilt_pct }}%

                Checks:
                - Tilt enabled: {{ tilt_enabled }}
                - Position < 80%: {{ position_pct < var_tilt_position_threshold_pct }}
                - State OK: {{ state_current not in ['moving_tilt', 'adjusting_tilt_ref'] }}
                - Lock OFF: {{ not tilt_lock }}
                - Lookahead < 80%: {{ position_after_tilt_pct < 80 }}

          # Bedingungen pr√ºfen
          - choose:
              # ALLE Bedingungen erf√ºllt ‚Üí apply_tilt
              - conditions: >
                  {{
                    tilt_enabled
                    and position_pct < var_tilt_position_threshold_pct
                    and state_current not in ['moving_tilt', 'adjusting_tilt_ref']
                    and not tilt_lock
                    and position_after_tilt_pct < 80
                  }}
                sequence:
                  - action: script.util_blinds_apply_tilt
                    data:
                      floor_slug: "{{ var_floor_slug }}"
                      room_slug: "{{ var_room_slug }}"

            # ELSE: Lookahead failed ‚Üí Tilt deaktivieren
            default:
              - if: >
                  {{
                    tilt_enabled
                    and position_after_tilt_pct >= 80
                  }}
                then:
                  - action: input_boolean.turn_off
                    target: { entity_id: "{{ var_tilt_enabled_entity_id }}" }
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Lookahead: Tilt deaktiviert"
                      message: |
                        Position nach Tilt w√§re {{ position_after_tilt_pct }}% >= 80%
                        ‚Üí Tilt wurde deaktiviert um Endlosschleife zu vermeiden

      # Trigger: Position >= 80% w√§hrend Fahrt (Auto-Disable)
      - conditions: "{{ trigger.id == 'position_high_tilt' }}"
        sequence:
          - variables:
              tilt_enabled: "{{ is_state(var_tilt_enabled_entity_id, 'on') }}"

          - if: "{{ tilt_enabled }}"
            then:
              - action: input_boolean.turn_off
                target: { entity_id: "{{ var_tilt_enabled_entity_id }}" }
              - action: input_number.set_value
                target: { entity_id: "{{ var_tilt_current_entity_id }}" }
                data: { value: 100 }
              - action: persistent_notification.create
                data:
                  title: "üö´ Auto-Disable (w√§hrend Fahrt)"
                  message: "Position √ºberschritt 80% w√§hrend Fahrt ‚Üí Tilt deaktiviert"
      # Taster gedr√ºckt ‚Üí Sofort-Stop, dann Kurz-/Langdruck mit State-Management
      - conditions: >
          {{
            trigger.platform == 'state'
            and trigger.entity_id in [var_up_button_entity_id, var_down_button_entity_id]
          }}
        sequence:
          - variables:
              is_up_press: "{{ trigger.entity_id == var_up_button_entity_id }}"
              status_now: "{{ states(var_status_sensor_entity_id) | int(0) }}"
              state_current: "{{ states(var_state_entity_id) }}"

          # Sofort-Stop wenn in Bewegung
          - if:
              - condition: template
                value_template: "{{ status_now in [2,3] or states(var_cover_entity_id) in ['opening','closing'] }}"
            then:
              - action: cover.stop_cover
                target: { entity_id: "{{ var_cover_entity_id }}" }
              # State auf idle setzen
              - action: input_select.select_option
                target: { entity_id: "{{ var_state_entity_id }}" }
                data: { option: "idle" }
              - stop: "Stopped because cover was moving"

          # Kurz/Langdruck (0.6s)
          - wait_template: "{{ is_state( (var_up_button_entity_id if is_up_press else var_down_button_entity_id), 'off') }}"
            timeout: "00:00:0.6"
            continue_on_timeout: true

          - choose:
              # Langdruck ‚Üí State setzen, dann Langdruck-Script
              - conditions: "{{ not wait.completed }}"
                sequence:
                  # Nur bei Langdruck State setzen
                  - if: "{{ state_current == 'idle' }}"
                    then:
                      - action: input_select.select_option
                        target: { entity_id: "{{ var_state_entity_id }}" }
                        data: { option: "moving_user" }

                  - action: script.util_blinds_longpress
                    data:
                      is_up: "{{ is_up_press }}"
                      coil_up_value: "{{ var_coil_up_value }}"
                      coil_down_value: "{{ var_coil_down_value }}"
                      pressed_button_entity_id: "{{ var_up_button_entity_id if is_up_press else var_down_button_entity_id }}"

              # Kurz-/Mehrfachklick ‚Üí KEIN State setzen, nur Counter
              - conditions: "{{ wait.completed }}"
                sequence:
                  - action: script.util_blinds_counter_click
                    data:
                      is_up: "{{ is_up_press }}"
                      counting_flag_entity_id: "{{ var_counting_flag_entity_id }}"
                      click_counter_entity_id: "{{ var_click_counter_entity_id }}"
                      last_direction_text_entity_id: "{{ var_last_direction_text_entity_id }}"
                      cover_entity_id: "{{ var_cover_entity_id }}"
                      floor_slug: "{{ var_floor_slug }}"
                      room_slug: "{{ var_room_slug }}"
                      state_entity_id: "{{ var_state_entity_id }}"
