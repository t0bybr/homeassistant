# =========================================================
# Jalousie Blueprint – LOGO/MQTT Tastersteuerung mit State Machine
# =========================================================
# Features:
# - State Machine: Klare Zustandsverwaltung (idle, moving_user, moving_automation, etc.)
# - Taster Hoch/Runter: Kurz-/Langdruck mit Sofort-Stop
# - Tilt-System: Automatisches Tracking + intelligente Drift-Vermeidung
# - Sequence-ID: Verhindert Endlosschleifen bei Multi-Step-Operationen
# - Wind-Sync & Position-Backup: Robuste LOGO-Integration
#
# State Machine:
# - idle: Bereit für neue Befehle
# - moving_user: Manuelle Tasterbedienung
# - moving_automation: Automatische Fahrt (Zeit, Szene)
# - moving_wind: Wind-Schutzfahrt
# - moving_tilt: Einfache Tilt-Anpassung
# - adjusting_tilt_ref: Multi-Step Tilt mit Referenzpunkt
# - recovering_position: LOGO-Neustart, Position-Sync
#
# Tilt-System:
# - tilt_current: Wird automatisch getrackt (0% = vertikal, 100% = horizontal)
# - tilt_target: Zielneigung (Standard: 75%, konfigurierbar)
# - tilt_enabled: Toggle via 2× Hoch-Taste
# - Drift-Vermeidung: Referenz-Methode bei Bewegungen < min_motor_ticks
#
# MQTT Signale:
# - logo/register/set/<target>: Zielposition in Ticks (oder 10000 = Bestätigung)
# - logo/register32/set/<counter>: Position-Counter Backup
# - logo/coil/set/<coil>: Motor an/aus (ON/OFF)
#
# LOGO Sensoren:
# - position_ticks_sensor: Aktuelle Position (0..max_travel_ticks)
# - movement_status_sensor: 0=closed, 1=idle/open, 2=closing, 3=opening
#
# Kalibrierung (im use_blueprint angeben):
# - max_travel_ticks: Maximaler Fahrweg in Ticks (gemessen)
# - tilt_ticks_close: Ticks von horizontal zu vertikal (z.B. 14)
# - tilt_ticks_open: Ticks von vertikal zu horizontal (z.B. 15)
# - min_motor_ticks: Minimale Bewegung die Motor ausführt (typ. 5)
# =========================================================

blueprint:
  name: Jalousie – LOGO/MQTT mit State Machine & Tilt
  description: >
    Intelligente Jalousie-Steuerung mit State Machine, automatischem Tilt-Tracking
    und Drift-Vermeidung. Features: Kurz/Langdruck, 2× Hoch = Tilt Toggle,
    Sequence-ID gegen Endlosschleifen, Wind-Sync, Position-Backup.
  domain: automation
  input:
    # Identifikation
    name:
      name: "Raum-Slug (z. B. wohnzimmer_west)"
      selector: { text: { multiline: false } }
    floor:
      name: "Stockwerk-Slug (z. B. 0)"
      selector: { text: { multiline: false } }

    # Taster
    up_button_entity_id:
      name: "Taster Hoch (binary_sensor)"
      selector: { entity: { filter: [{ domain: binary_sensor }] } }
    down_button_entity_id:
      name: "Taster Runter (binary_sensor)"
      selector: { entity: { filter: [{ domain: binary_sensor }] } }

    # Cover
    cover_entity:
      name: "Cover-Entität (Template-Cover)"
      selector: { entity: { filter: [{ domain: cover }] } }

    # Interner State (input_select)
    state_entity_id:
      name: "State-Helper (input_select.*_state)"
      selector: { entity: { filter: [{ domain: input_select }] } }

    # Tilt-Konfiguration
    tilt_target_default:
      name: "Standard-Neigung beim Toggle (0-100%)"
      selector: { number: { min: 0, max: 100, step: 5, mode: slider } }
      default: 75

    tilt_position_threshold_pct:
      name: "Maximale Position für Tilt (%)"
      description: "Tilt nur verfügbar wenn Position < dieser Wert"
      selector: { number: { min: 0, max: 100, step: 5, mode: slider } }
      default: 80

    # LOGO/MQTT Parameter
    coil_up:
      name: "LOGO Coil: hoch"
      selector: { number: { min: 1, max: 9999, mode: box } }
    coil_down:
      name: "LOGO Coil: runter"
      selector: { number: { min: 1, max: 9999, mode: box } }
    register_target:
      name: "LOGO Register: Zielposition (Ticks)"
      selector: { number: { min: 1, max: 9999, mode: box } }
    register_max_ticks_limit:
      name: "LOGO Register: max. Fahrweg/-dauer (Ticks-Limit)"
      selector: { number: { min: 1, max: 9999, mode: box } }
    register_counter:
      name: "LOGO Register: Counter/Position (für Backup)"
      selector: { number: { min: 1, max: 9999, mode: box } }

    # Skalierung & Sensoren
    max_travel_ticks:
      name: "Max. Fahrweg in Ticks (100%)"
      selector: { number: { min: 1, max: 5000, mode: box } }
    position_ticks_sensor_entity_id:
      name: "Positionssensor in Ticks (0..max_travel_ticks)"
      selector: { entity: { filter: [{ domain: sensor }] } }
    movement_status_sensor_entity_id:
      name: "Statussensor (0=closed,1=idle/open,2=closing,3=opening)"
      selector: { entity: { filter: [{ domain: sensor }] } }

mode: parallel
max: 10

# -----------------------------
# TRIGGER
# -----------------------------
trigger:
  # Taster
  - trigger: state
    entity_id: !input up_button_entity_id
    from: "off"
    to: "on"
  - trigger: state
    entity_id: !input down_button_entity_id
    from: "off"
    to: "on"

  # HA-Start → Limit setzen
  - trigger: homeassistant
    event: start

  # Automations-Reload → Limit erneut setzen
  - trigger: event
    event_type: automation_reloaded

  # Positionsänderung (Ticks) – für Tilt-Reset > Schwelle
  - trigger: state
    entity_id: !input position_ticks_sensor_entity_id

  # Statuswechsel (Fahrt beginnt/endet)
  - trigger: state
    entity_id: !input movement_status_sensor_entity_id

  # Statewechsel (für Tilt-Nachstellung bei Rückkehr nach idle)
  - trigger: state
    entity_id: !input state_entity_id

  # Wind-Sensor
  - trigger: state
    entity_id: binary_sensor.mosquitto_broker_mqtt_logo_coil_20

# -----------------------------
# VARIABLEN (sprechende Namen)
# -----------------------------
variables:
  # Slugs
  var_floor_slug: !input floor
  var_room_slug: !input name

  # Entitäten, die als Inputs kommen
  var_cover_entity_id: !input cover_entity

  # Abgeleitete Entitäten (müssen zu deinen Helpers passen!)
  var_state_entity_id: !input state_entity_id
  var_sequence_id_entity_id: "input_text.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_sequence_id"

  var_counting_flag_entity_id: "input_boolean.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_counting"
  var_click_counter_entity_id: "counter.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_clicks"
  var_last_direction_text_entity_id: "input_text.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_last_direction_text"

  # Letzter Bewegungsstatus (input_number, 2=closing, 3=opening)
  var_last_moving_state_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_last_moving_state"
  var_position_backup_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_position_backup"

  # Tilt-Entitäten
  var_tilt_enabled_entity_id: "input_boolean.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_enabled"
  var_tilt_current_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_current"
  var_tilt_target_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_target"
  var_tilt_ticks_close_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_ticks_close"
  var_tilt_ticks_open_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_ticks_open"
  var_min_motor_ticks_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_min_motor_ticks"

  # UI-/Helper (sichtbar in HA) – **an deine Namen angepasst**
  var_target_register_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_logo_register_target"
  var_max_travel_ticks_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_max_travel_ticks"
  var_coil_up_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_logo_coil_up"
  var_coil_down_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_logo_coil_down"

  # Inputs aus Blueprint
  var_status_sensor_entity_id: !input movement_status_sensor_entity_id
  var_up_button_entity_id: !input up_button_entity_id
  var_down_button_entity_id: !input down_button_entity_id
  var_logo_register_target: !input register_target
  var_logo_register_max_limit: !input register_max_ticks_limit
  var_logo_register_counter: !input register_counter
  var_max_travel_ticks_value: !input max_travel_ticks
  var_position_ticks_sensor_entity_id: !input position_ticks_sensor_entity_id
  var_coil_up_value: !input coil_up
  var_coil_down_value: !input coil_down

  # Tilt-Konfiguration (aus Inputs)
  var_tilt_target_default: !input tilt_target_default
  var_tilt_position_threshold_pct: !input tilt_position_threshold_pct

# -----------------------------
# ACTIONS
# -----------------------------
action:
  - choose:
      # Wind-Ende Sync
      - conditions: >
          {{
            trigger.entity_id == 'binary_sensor.mosquitto_broker_mqtt_logo_coil_20'
            and trigger.from_state.state == 'on'
            and trigger.to_state.state == 'off'
          }}
        sequence:
          - action: mqtt.publish
            data:
              topic: "logo/register32/set/{{ var_logo_register_counter }}"
              payload: "{{ states(var_max_travel_ticks_value) | int }}"

      # Wenn die Logo neu startet und die Positionswerte nicht mehr passen
      - conditions: >
          {{
            trigger.entity_id == var_position_ticks_sensor_entity_id
            and (trigger.to_state.state is not none)
            and (trigger.to_state.state | int in [0])
            and (states(var_position_backup_number_entity_id) | int(-1) not in [0])
          }}
        sequence:
          - action: mqtt.publish
            data:
              topic: "logo/register32/set/{{ var_logo_register_counter }}"
              payload: "{{ states(var_position_backup_number_entity_id) | int }}"

      # Positionswert in Backup schreiben
      - conditions: >
          {{
            trigger.entity_id == var_position_ticks_sensor_entity_id
            and (trigger.to_state.state is not none)
          }}
        sequence:
          - action: input_number.set_value
            target:
              entity_id: "{{ var_position_backup_number_entity_id }}"
            data:
              value: "{{ states(var_position_ticks_sensor_entity_id) | int }}"

      # Fahrt startet: 0/1 → 2/3 → Tilt-Current aktualisieren (nur wenn nicht Tilt-Operation)
      - conditions: >
          {{
            trigger.entity_id == var_status_sensor_entity_id
            and (trigger.from_state is not none)
            and (trigger.from_state.state | int(0)) in [0,1]
            and (trigger.to_state.state   | int(0)) in [2,3]
            and states(var_state_entity_id) not in ['moving_tilt', 'adjusting_tilt_ref']
          }}
        sequence:
          # Fallback: Start aus idle → als moving_automation markieren
          - if: "{{ states(var_state_entity_id) == 'idle' }}"
            then:
              - action: input_select.select_option
                target: { entity_id: "{{ var_state_entity_id }}" }
                data: { option: "moving_automation" }

          - variables:
              new_status: "{{ trigger.to_state.state | int(0) }}"
          # Update tilt_current basierend auf Fahrtrichtung (nur bei User/Automation-Fahrten)
          - action: input_number.set_value
            target: { entity_id: "{{ var_tilt_current_entity_id }}" }
            data:
              value: >
                {% if new_status == 3 %}
                  100
                {% elif new_status == 2 %}
                  0
                {% else %}
                  {{ states(var_tilt_current_entity_id) | int(0) }}
                {% endif %}
          - stop: "Tilt current updated on movement start"

      # Fahrt endet: 2/3 → 0/1 → bestätigen + Richtung speichern + ggf. Tilt auto-disable
      - conditions: >
          {{
            trigger.entity_id == var_status_sensor_entity_id
            and (trigger.from_state is not none)
            and (trigger.from_state.state | int(0)) in [2,3]
            and (trigger.to_state.state   | int(0)) in [0,1]
          }}
        sequence:
          - delay: "00:00:0.3"
          - choose:
              - conditions: "{{ states(var_status_sensor_entity_id) | int(0) in [0,1] }}"
                sequence:
                  # Bestätigung an LOGO
                  - action: mqtt.publish
                    data:
                      topic: "logo/register/set/{{ var_logo_register_target }}"
                      payload: "10000"

                  # Letzte Richtung merken
                  - variables:
                      dir_before: "{{ trigger.from_state.state | int(0) }}"
                  - action: input_number.set_value
                    target: { entity_id: "{{ var_last_moving_state_number_entity_id }}" }
                    data: { value: "{{ dir_before }}" }

                  # Position berechnen
                  - variables:
                      current_pct: >
                        {% set ticks = states(var_position_ticks_sensor_entity_id) | int(0) %}
                        {% set max_ticks = var_max_travel_ticks_value | int(1) %}
                        {{ (100.0 * ticks / max_ticks) | round(0) | int }}
                      state_current: "{{ states(var_state_entity_id) }}"

                  # Tilt auto-disable wenn Position >= Schwelle (unabhängig von Richtung)
                  - if: "{{ current_pct >= var_tilt_position_threshold_pct }}"
                    then:
                      - action: input_boolean.turn_off
                        target: { entity_id: "{{ var_tilt_enabled_entity_id }}" }
                      # tilt_current bleibt unverändert

                  # State zurück auf idle (wenn nicht durch Tilt-Script geändert)
                  - if: "{{ states(var_state_entity_id) in ['moving_user', 'moving_automation'] }}"
                    then:
                      - action: input_select.select_option
                        target: { entity_id: "{{ var_state_entity_id }}" }
                        data: { option: "idle" }
          - stop: "Handled stop + tilt"

      # State → idle: Tilt anwenden (nur nach User/Automation-Fahrten)
      - conditions: >
          {{
            trigger.entity_id == var_state_entity_id
            and (trigger.from_state is not none)
            and (trigger.from_state.state | string) in ['moving_user','moving_automation']
            and (trigger.to_state.state   | string) == 'idle'
          }}
        sequence:
          - variables:
              current_pct: >
                {% set ticks = states(var_position_ticks_sensor_entity_id) | int(0) %}
                {% set max_ticks = var_max_travel_ticks_value | int(1) %}
                {{ (100.0 * ticks / max_ticks) | round(0) | int }}
              tilt_enabled: "{{ is_state(var_tilt_enabled_entity_id, 'on') }}"

          - if: >
              {{ tilt_enabled and current_pct < var_tilt_position_threshold_pct }}
            then:
              - action: script.util_blinds_apply_tilt
                data:
                  floor_slug: "{{ var_floor_slug }}"
                  room_slug: "{{ var_room_slug }}"
          - stop: "Applied tilt on idle"

      # HA-Start/Reload → LOGO-Limit & UI-Helper syncen + State initialisieren
      - conditions: >
          {{
            trigger.platform == 'homeassistant'
            or (
              trigger.platform == 'event'
              and trigger.event.event_type == 'automation_reloaded'
            )
          }}
        sequence:
          - action: mqtt.publish
            data:
              topic: "logo/register/set/{{ var_logo_register_max_limit }}"
              payload: "{{ var_max_travel_ticks_value }}"
          - action: input_number.set_value
            target: { entity_id: "{{ var_max_travel_ticks_number_entity_id }}" }
            data: { value: "{{ var_max_travel_ticks_value }}" }
          - action: input_number.set_value
            target: { entity_id: "{{ var_target_register_number_entity_id }}" }
            data: { value: "{{ var_logo_register_target }}" }
          - action: input_number.set_value
            target: { entity_id: "{{ var_coil_up_number_entity_id }}" }
            data: { value: "{{ var_coil_up_value }}" }
          - action: input_number.set_value
            target: { entity_id: "{{ var_coil_down_number_entity_id }}" }
            data: { value: "{{ var_coil_down_value }}" }
          # State auf idle zurücksetzen
          - action: input_select.select_option
            target: { entity_id: "{{ var_state_entity_id }}" }
            data: { option: "idle" }
          # Sequence ID leeren
          - action: input_text.set_value
            target: { entity_id: "{{ var_sequence_id_entity_id }}" }
            data: { value: "" }
          # Tilt-Target initialisieren wenn noch leer
          - if: "{{ states(var_tilt_target_entity_id) | int(0) == 0 }}"
            then:
              - action: input_number.set_value
                target: { entity_id: "{{ var_tilt_target_entity_id }}" }
                data: { value: "{{ var_tilt_target_default }}" }

      # Taster gedrückt → Sofort-Stop, dann Kurz-/Langdruck mit State-Management
      - conditions: >
          {{
            trigger.platform == 'state'
            and trigger.entity_id in [var_up_button_entity_id, var_down_button_entity_id]
          }}
        sequence:
          - variables:
              is_up_press: "{{ trigger.entity_id == var_up_button_entity_id }}"
              status_now: "{{ states(var_status_sensor_entity_id) | int(0) }}"
              state_current: "{{ states(var_state_entity_id) }}"

          # Sofort-Stop wenn in Bewegung
          - if:
              - condition: template
                value_template: "{{ status_now in [2,3] or states(var_cover_entity_id) in ['opening','closing'] }}"
            then:
              - action: cover.stop_cover
                target: { entity_id: "{{ var_cover_entity_id }}" }
              # State auf idle setzen
              - action: input_select.select_option
                target: { entity_id: "{{ var_state_entity_id }}" }
                data: { option: "idle" }
              - stop: "Stopped because cover was moving"

          # Kurz/Langdruck (0.6s)
          - wait_template: "{{ is_state( (var_up_button_entity_id if is_up_press else var_down_button_entity_id), 'off') }}"
            timeout: "00:00:0.6"
            continue_on_timeout: true

          - choose:
              # Langdruck → State setzen, dann Langdruck-Script
              - conditions: "{{ not wait.completed }}"
                sequence:
                  # Nur bei Langdruck State setzen
                  - if: "{{ state_current == 'idle' }}"
                    then:
                      - action: input_select.select_option
                        target: { entity_id: "{{ var_state_entity_id }}" }
                        data: { option: "moving_user" }

                  - action: script.util_blinds_longpress
                    data:
                      is_up: "{{ is_up_press }}"
                      coil_up_value: "{{ var_coil_up_value }}"
                      coil_down_value: "{{ var_coil_down_value }}"
                      pressed_button_entity_id: "{{ var_up_button_entity_id if is_up_press else var_down_button_entity_id }}"

              # Kurz-/Mehrfachklick → KEIN State setzen, nur Counter
              - conditions: "{{ wait.completed }}"
                sequence:
                  - action: script.util_blinds_counter_click
                    data:
                      is_up: "{{ is_up_press }}"
                      counting_flag_entity_id: "{{ var_counting_flag_entity_id }}"
                      click_counter_entity_id: "{{ var_click_counter_entity_id }}"
                      last_direction_text_entity_id: "{{ var_last_direction_text_entity_id }}"
                      cover_entity_id: "{{ var_cover_entity_id }}"
                      floor_slug: "{{ var_floor_slug }}"
                      room_slug: "{{ var_room_slug }}"
                      state_entity_id: "{{ var_state_entity_id }}"
