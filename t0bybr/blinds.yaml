# =========================================================
# Jalousie Blueprint – LOGO/MQTT Tastersteuerung mit State Machine
# =========================================================

blueprint:
  name: Jalousie – LOGO/MQTT mit State Machine & einfachem Tilt
  description: >
    Jalousie-Steuerung mit State Machine, Kurz/Langdruck und einfachem Tilt:
    2× Hoch toggelt tilt_enabled (Bool) und fährt die Lamellen:
    - ON: auf tilt_target (abhängig von letzter Nicht-Tilt-Fahrtrichtung)
    - OFF: zurück zur Basisstellung.
    Wenn bei aktivem Tilt eine andere Fahrt endet, wird Tilt nur deaktiviert.
  domain: automation
  input:
    name:
      name: "Raum-Slug (z. B. dining_room)"
      selector: { text: { multiline: false } }
    floor:
      name: "Stockwerk-Slug (z. B. 0)"
      selector: { text: { multiline: false } }

    up_button_entity_id:
      name: "Taster Hoch (binary_sensor)"
      selector: { entity: { filter: [{ domain: binary_sensor }] } }
    down_button_entity_id:
      name: "Taster Runter (binary_sensor)"
      selector: { entity: { filter: [{ domain: binary_sensor }] } }

    cover_entity:
      name: "Cover-Entität (Template-Cover)"
      selector: { entity: { filter: [{ domain: cover }] } }

    tilt_enabled_entity_id:
      name: "Tilt Enabled Entity (input_boolean)"
      selector: { entity: { filter: [{ domain: input_boolean }] } }

    tilt_target_default:
      name: "Standard-Neigung beim Toggle (0-100%)"
      selector: { number: { min: 0, max: 100, step: 5, mode: slider } }
      default: 75

    tilt_position_threshold_pct:
      name: "Maximale Position für Tilt (%)"
      description: "Tilt nur verfügbar wenn Position < dieser Wert (nur UI-Flag)"
      selector: { number: { min: 0, max: 100, step: 5, mode: slider } }
      default: 80

    coil_up:
      name: "LOGO Coil: hoch"
      selector: { number: { min: 1, max: 9999, mode: box } }
    coil_down:
      name: "LOGO Coil: runter"
      selector: { number: { min: 1, max: 9999, mode: box } }
    register_target:
      name: "LOGO Register: Zielposition (Ticks)"
      selector: { number: { min: 1, max: 9999, mode: box } }
    register_max_ticks_limit:
      name: "LOGO Register: max. Fahrweg/-dauer (Ticks-Limit)"
      selector: { number: { min: 1, max: 9999, mode: box } }
    register_counter:
      name: "LOGO Register: Counter/Position (für Backup)"
      selector: { number: { min: 1, max: 9999, mode: box } }

    max_travel_ticks:
      name: "Max. Fahrweg in Ticks (100%)"
      selector: { number: { min: 1, max: 5000, mode: box } }
    position_ticks_sensor_entity_id:
      name: "Positionssensor in Ticks (0..max_travel_ticks)"
      selector: { entity: { filter: [{ domain: sensor }] } }
    movement_status_sensor_entity_id:
      name: "Statussensor (0=closed,1=idle/open,2=closing,3=opening)"
      selector: { entity: { filter: [{ domain: sensor }] } }

mode: parallel
max: 10

trigger:
  - trigger: state
    entity_id: !input up_button_entity_id
    from: "off"
    to: "on"
    id: button_up

  - trigger: state
    entity_id: !input down_button_entity_id
    from: "off"
    to: "on"
    id: button_down

  - trigger: homeassistant
    event: start
    id: ha_start

  - trigger: event
    event_type: automation_reloaded
    id: automation_reload

  - trigger: state
    entity_id: !input movement_status_sensor_entity_id
    id: status_change

  - trigger: state
    entity_id: !input position_ticks_sensor_entity_id
    id: position_change

  - trigger: state
    entity_id: binary_sensor.mosquitto_broker_mqtt_logo_coil_20
    id: wind_change

  - trigger: state
    entity_id: !input tilt_enabled_entity_id
    id: tilt_toggle

variables:
  var_floor_slug: !input floor
  var_room_slug: !input name

  var_cover_entity_id: !input cover_entity

  var_state_entity_id: "input_select.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_state"

  var_counting_flag_entity_id: "input_boolean.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_counting"
  var_click_counter_entity_id: "counter.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_clicks"
  var_last_direction_text_entity_id: "input_text.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_last_direction_text"

  var_position_state_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_position_state"
  var_last_moving_state_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_last_moving_state"
  var_position_backup_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_position_backup"
  var_movement_start_ticks_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_movement_start_ticks"

  var_tilt_enabled_entity_id: "input_boolean.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_enabled"
  var_tilt_target_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_target"
  var_tilt_available_entity_id: "input_boolean.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_available"
  var_tilt_lock_entity_id: "input_boolean.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_lock"
  var_tilt_ticks_close_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_ticks_close"
  var_tilt_ticks_open_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_tilt_ticks_open"

  var_target_register_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_logo_register_target"
  var_max_travel_ticks_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_max_travel_ticks"
  var_coil_up_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_logo_coil_up"
  var_coil_down_number_entity_id: "input_number.blinds_{{ var_floor_slug }}_{{ var_room_slug }}_logo_coil_down"

  var_status_sensor_entity_id: !input movement_status_sensor_entity_id
  var_up_button_entity_id: !input up_button_entity_id
  var_down_button_entity_id: !input down_button_entity_id
  var_logo_register_target: !input register_target
  var_logo_register_max_limit: !input register_max_ticks_limit
  var_logo_register_counter: !input register_counter
  var_max_travel_ticks_value: !input max_travel_ticks
  var_position_ticks_sensor_entity_id: !input position_ticks_sensor_entity_id
  var_coil_up_value: !input coil_up
  var_coil_down_value: !input coil_down

  var_tilt_target_default: !input tilt_target_default
  var_tilt_position_threshold_pct: !input tilt_position_threshold_pct

action:
  - choose:
      # Wind-Ende Sync
      - conditions: >
          {{
            trigger.id == 'wind_change'
            and trigger.from_state.state == 'on'
            and trigger.to_state.state == 'off'
          }}
        sequence:
          - action: mqtt.publish
            data:
              topic: "logo/register32/set/{{ var_logo_register_counter }}"
              payload: "{{ var_max_travel_ticks_value }}"

      # LOGO-Reset: Position korrigieren
      - conditions: >
          {{
            trigger.id == 'position_change'
            and (trigger.to_state.state is not none)
            and (trigger.to_state.state | int in [0])
            and (states(var_position_backup_number_entity_id) | int(-1) not in [0])
          }}
        sequence:
          - action: mqtt.publish
            data:
              topic: "logo/register32/set/{{ var_logo_register_counter }}"
              payload: "{{ states(var_position_backup_number_entity_id) | int }}"

      # Position → Backup & Tilt-Availability
      - conditions: >
          {{
            trigger.id == 'position_change'
            and (trigger.to_state.state is not none)
          }}
        sequence:
          - action: input_number.set_value
            target:
              entity_id: "{{ var_position_backup_number_entity_id }}"
            data:
              value: "{{ states(var_position_ticks_sensor_entity_id) | int }}"

          - variables:
              _pos: "{{ states(var_position_ticks_sensor_entity_id) | int(0) }}"
              _status: "{{ states(var_status_sensor_entity_id) | int(0) }}"
              _pos_pct: "{{ (100.0 * _pos / var_max_travel_ticks_value) | round(0) | int }}"
              _avail: "{{ _status == 1 and _pos_pct < var_tilt_position_threshold_pct }}"
          - choose:
              - conditions: "{{ _avail }}"
                sequence:
                  - action: input_boolean.turn_on
                    target: { entity_id: "{{ var_tilt_available_entity_id }}" }
              - conditions: "{{ not _avail }}"
                sequence:
                  - action: input_boolean.turn_off
                    target: { entity_id: "{{ var_tilt_available_entity_id }}" }

      - conditions: >
          {{
            trigger.id == 'status_change'
          }}
        sequence:
          - action: input_number.set_value
            target: { entity_id: "{{ var_position_state_number_entity_id }}" }
            data:
              { value: "{{ states(var_status_sensor_entity_id) | float(0) }}" }

      # Fahrt startet: 0/1 → 2/3
      - conditions: >
          {{
            trigger.id == 'status_change'
            and (trigger.from_state is not none)
            and (trigger.from_state.state | int(0)) in [0,1]
            and (trigger.to_state.state   | int(0)) in [2,3]
          }}
        sequence:
          - if: "{{ states(var_state_entity_id) == 'idle' }}"
            then:
              - action: input_select.select_option
                target: { entity_id: "{{ var_state_entity_id }}" }
                data: { option: "moving_automation" }

          - variables:
              current_ticks_start: "{{ states(var_position_ticks_sensor_entity_id) | int(0) }}"
              _tilt_enabled: "{{ is_state(var_tilt_enabled_entity_id, 'on') }}"
              _tilt_lock: "{{ is_state(var_tilt_lock_entity_id, 'on') }}"

          #    Auto-Off für Tilt, wenn die Jalousie bei aktivem Tilt bewegt wird
          #    (aber NICHT, wenn gerade ein Tilt-Script läuft → _tilt_lock)
          - if:
              - "{{ _tilt_enabled }}"
              - "{{ not _tilt_lock }}"
            then:
              - action: input_boolean.turn_off
                target: { entity_id: "{{ var_tilt_enabled_entity_id }}" }

          - action: input_number.set_value
            target: { entity_id: "{{ var_movement_start_ticks_entity_id }}" }
            data: { value: "{{ current_ticks_start }}" }

          # last_moving_state nur aktualisieren, wenn kein Tilt läuft
          - if: "{{
              not _tilt_lock
              and (states(var_status_sensor_entity_id) | int) in [2, 3]
              }}"
            then:
              - action: input_number.set_value
                target:
                  { entity_id: "{{ var_last_moving_state_number_entity_id }}" }
                data:
                  { value: "{{ states(var_status_sensor_entity_id) | int }}" }

          - variables:
              _pos: "{{ states(var_position_ticks_sensor_entity_id) | int(0) }}"
              _status: "{{ states(var_status_sensor_entity_id) | int(0) }}"
              _pos_pct: "{{ (100.0 * _pos / var_max_travel_ticks_value) | round(0) | int }}"
              _avail: "{{ _status == 1 and _pos_pct < var_tilt_position_threshold_pct }}"
          - choose:
              - conditions: "{{ _avail }}"
                sequence:
                  - action: input_boolean.turn_on
                    target: { entity_id: "{{ var_tilt_available_entity_id }}" }
              - conditions: "{{ not _avail }}"
                sequence:
                  - action: input_boolean.turn_off
                    target: { entity_id: "{{ var_tilt_available_entity_id }}" }
          - stop: "Movement start handled"

      # Fahrt endet: 2/3 → 0/1
      - conditions: >
          {{
            trigger.id == 'status_change'
            and (trigger.from_state is not none)
            and (trigger.from_state.state | int(0)) in [2,3]
            and (trigger.to_state.state   | int(0)) in [0,1]
          }}
        sequence:
          - delay: "00:00:0.3"
          - choose:
              - conditions: "{{ states(var_status_sensor_entity_id) | int(0) in [0,1] }}"
                sequence:
                  - action: mqtt.publish
                    data:
                      topic: "logo/register/set/{{ var_logo_register_target }}"
                      payload: "10000"

                  - if: "{{ states(var_state_entity_id) in ['moving_user', 'moving_automation', 'moving_wind'] }}"
                    then:
                      - action: input_select.select_option
                        target: { entity_id: "{{ var_state_entity_id }}" }
                        data: { option: "idle" }
          - stop: "Handled movement end"

      # HA-Start/Reload
      - conditions: "{{ trigger.id in ['ha_start', 'automation_reload'] }}"
        sequence:
          - action: mqtt.publish
            data:
              topic: "logo/register/set/{{ var_logo_register_max_limit }}"
              payload: "{{ var_max_travel_ticks_value }}"
          - action: input_number.set_value
            target: { entity_id: "{{ var_max_travel_ticks_number_entity_id }}" }
            data: { value: "{{ var_max_travel_ticks_value }}" }
          - action: input_number.set_value
            target: { entity_id: "{{ var_target_register_number_entity_id }}" }
            data: { value: "{{ var_logo_register_target }}" }
          - action: input_number.set_value
            target: { entity_id: "{{ var_coil_up_number_entity_id }}" }
            data: { value: "{{ var_coil_up_value }}" }
          - action: input_number.set_value
            target: { entity_id: "{{ var_coil_down_number_entity_id }}" }
            data: { value: "{{ var_coil_down_value }}" }

          - action: input_select.select_option
            target: { entity_id: "{{ var_state_entity_id }}" }
            data: { option: "idle" }

          - if: "{{ states(var_tilt_target_entity_id) | int(0) == 0 }}"
            then:
              - action: input_number.set_value
                target: { entity_id: "{{ var_tilt_target_entity_id }}" }
                data: { value: "{{ var_tilt_target_default }}" }

      # ========================================
      # TILT-CONTROLLER
      # ========================================

      - conditions: "{{
          (trigger.id == 'tilt_toggle')
          and (is_state(var_state_entity_id, 'idle'))
          }}"
        sequence:
          - delay: "00:00:01"

          - if: "{{ states(var_tilt_target_entity_id) | int(0) == 0 }}"
            then:
              - action: input_number.set_value
                target: { entity_id: "{{ var_tilt_target_entity_id }}" }
                data: { value: "{{ var_tilt_target_default }}" }

          - choose:
              # Tilt ON → Fahre auf tilt_target
              - conditions: "{{ trigger.to_state.state == 'on' }}"
                sequence:
                  - action: script.util_blinds_tilt_simple
                    data:
                      floor_slug: "{{ var_floor_slug }}"
                      room_slug: "{{ var_room_slug }}"
                      tilt_mode: "on"
                      position_sensor_entity_id: "{{ var_position_ticks_sensor_entity_id }}"
                      last_moving_state_entity_id: "{{ var_last_moving_state_number_entity_id }}"

              # Tilt OFF → zurück zur Basis
              - conditions: "{{ trigger.to_state.state == 'off' }}"
                sequence:
                  - action: script.util_blinds_tilt_simple
                    data:
                      floor_slug: "{{ var_floor_slug }}"
                      room_slug: "{{ var_room_slug }}"
                      tilt_mode: "off"
                      position_sensor_entity_id: "{{ var_position_ticks_sensor_entity_id }}"
                      last_moving_state_entity_id: "{{ var_last_moving_state_number_entity_id }}"

      # Taster gedrückt → Stop / Kurz / Lang
      - conditions: "{{ trigger.id in ['button_up', 'button_down'] }}"
        sequence:
          - variables:
              is_up_press: "{{ trigger.id == 'button_up' }}"
              status_now: "{{ states(var_status_sensor_entity_id) | int(0) }}"
              state_current: "{{ states(var_state_entity_id) }}"

          - if:
              - condition: template
                value_template: "{{ status_now in [2,3] or states(var_cover_entity_id) in ['opening','closing'] }}"
            then:
              - action: cover.stop_cover
                target: { entity_id: "{{ var_cover_entity_id }}" }
              - action: input_select.select_option
                target: { entity_id: "{{ var_state_entity_id }}" }
                data: { option: "idle" }
              - stop: "Stopped because cover was moving"

          - wait_template: "{{ is_state( (var_up_button_entity_id if is_up_press else var_down_button_entity_id), 'off') }}"
            timeout: "00:00:0.6"
            continue_on_timeout: true

          - choose:
              # Langdruck
              - conditions: "{{ not wait.completed }}"
                sequence:
                  - if: "{{ state_current == 'idle' }}"
                    then:
                      - action: input_select.select_option
                        target: { entity_id: "{{ var_state_entity_id }}" }
                        data: { option: "moving_user" }

                  - action: script.util_blinds_longpress
                    data:
                      is_up: "{{ is_up_press }}"
                      coil_up_value: "{{ var_coil_up_value }}"
                      coil_down_value: "{{ var_coil_down_value }}"
                      pressed_button_entity_id: "{{ var_up_button_entity_id if is_up_press else var_down_button_entity_id }}"

              # Kurz-/Mehrfachklick
              - conditions: "{{ wait.completed }}"
                sequence:
                  - action: script.util_blinds_counter_click
                    data:
                      is_up: "{{ is_up_press }}"
                      counting_flag_entity_id: "{{ var_counting_flag_entity_id }}"
                      click_counter_entity_id: "{{ var_click_counter_entity_id }}"
                      last_direction_text_entity_id: "{{ var_last_direction_text_entity_id }}"
                      cover_entity_id: "{{ var_cover_entity_id }}"
                      floor_slug: "{{ var_floor_slug }}"
                      room_slug: "{{ var_room_slug }}"
                      state_entity_id: "{{ var_state_entity_id }}"
