# =========================================================
# README Â· Blinds/LOGO Utility-Skripte (konsistente Benennung)
# ---------------------------------------------------------
# Enthaltene Skripte
# - util_blinds_tilt_step_ticks_dir
#     Adaptiver Tilt-Schritt in Ticks, abhÃ¤ngig von:
#       â€¢ letzter Bewegungsrichtung (2=closing/runter, 3=opening/hoch)
#       â€¢ aktueller Position (Interpolation zwischen â€žuntenâ€œ- und â€žobenâ€œ-Schritt)
#       â€¢ je Richtung separat kalibrierbaren SchrittgrÃ¶ÃŸen (Ticks)
#
# - util_blinds_longpress
#     HÃ¤lt die passende LOGO-Coil (hoch/runter), bis der Button losgelassen wird
#     oder ein Safety-Timeout greift.
#
# - util_blinds_counter_click + util_blinds_counter_window
#     KlickzÃ¤hler (Fenster 2s): 1Ã— open/close, 2Ã— Tilt-Flag toggle, 3/4Ã— optional.
#
# Namenskonvention
# - *_entity_id  â€¦ erwartet eine Entity-ID (z. B. cover.*, input_boolean.*, counter.*)
# - *_value      â€¦ reine Werte (Zahlen)
# - *_number_entity_id â€¦ input_number-EntitÃ¤t
#
# MQTT (erwartete Topics)
# - logo/register/set/<number>  (payload: Ticks-Ziel oder â€ž10000â€œ)
# - logo/coil/set/<number>      (payload: "ON"/"OFF")
# =========================================================

script:
  # -------------------------------------------------------
  # Tilt anwenden (neues System mit Referenz-Methode)
  # -------------------------------------------------------
  util_blinds_apply_tilt:
    alias: "Blinds Â· Tilt anwenden"
    mode: queued
    max: 10
    fields:
      floor_slug:
        description: "Stockwerk-Slug (z. B. '0')"
      room_slug:
        description: "Raum-Slug (z. B. 'living_room_west')"

    sequence:
      - variables:
          # Slugs als Strings sicherstellen
          floor_slug_str: "{{ floor_slug | string }}"
          room_slug_str: "{{ room_slug | string }}"

          # EntitÃ¤ten ableiten
          state_entity: "input_select.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_state"
          sequence_id_entity: "input_text.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_sequence_id"
          tilt_enabled_entity: "input_boolean.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_enabled"
          tilt_current_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_current"
          tilt_target_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_target"
          tilt_ticks_close_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_ticks_close"
          tilt_ticks_open_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_ticks_open"
          min_motor_ticks_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_min_motor_ticks"
          position_sensor: "sensor.mosquitto_broker_mqtt_logo_hr_104_position_raw"
          register_target_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_logo_register_target"
          status_sensor: "sensor.mosquitto_broker_mqtt_logo_hr_104_status"

          # Werte lesen
          tilt_enabled: "{{ is_state(tilt_enabled_entity, 'on') }}"
          tilt_current: "{{ states(tilt_current_entity) | int(0) }}"
          tilt_target: "{{ states(tilt_target_entity) | int(75) }}"
          tilt_ticks_close: "{{ states(tilt_ticks_close_entity) | int(14) }}"
          tilt_ticks_open: "{{ states(tilt_ticks_open_entity) | int(15) }}"
          min_motor_ticks: "{{ states(min_motor_ticks_entity) | int(5) }}"
          current_pos: "{{ states(position_sensor) | int(0) }}"
          register_target: "{{ states(register_target_entity) | int(535) }}"

      # DEBUG: Script Entry
      - action: persistent_notification.create
        data:
          title: "ðŸŸ¢ apply_tilt gestartet"
          message: |
            Tilt enabled: {{ tilt_enabled }}
            Tilt current: {{ tilt_current }}%
            Tilt target: {{ tilt_target }}%
            Position: {{ current_pos }} ticks

      # PrÃ¼fen ob Tilt Ã¼berhaupt aktiv
      - if: "{{ not tilt_enabled }}"
        then:
          # DEBUG
          - action: persistent_notification.create
            data:
              title: "ðŸ”´ Tilt DISABLED â†’ fahre zu 0%"
              message: |
                Current: {{ tilt_current }}%
                Wird bewegen? {{ 'JA' if tilt_current != 0 else 'NEIN (schon bei 0%)' }}

          # Tilt wurde deaktiviert â†’ Fahre zu 0% (vertikal geschlossen)
          - if: "{{ tilt_current != 0 }}"
            then:
              - action: input_select.select_option
                target: { entity_id: "{{ state_entity }}" }
                data: { option: "moving_tilt" }

              - variables:
                  # Von current% zu 0% â†’ runter fahren
                  ticks_needed: "{{ (tilt_current / 100.0 * tilt_ticks_close) | round(0) | int }}"

              - action: persistent_notification.create
                data:
                  title: "ðŸ“¤ MQTT gesendet"
                  message: |
                    Topic: logo/register/set/{{ register_target }}
                    Payload: {{ current_pos - ticks_needed }}
                    ({{ current_pos }} - {{ ticks_needed }} ticks)

              - action: mqtt.publish
                data:
                  topic: "logo/register/set/{{ register_target }}"
                  payload: "{{ current_pos - ticks_needed }}"

              - wait_template: "{{ states(status_sensor) | int(0) in [0,1] }}"
                timeout: "00:00:10"

              - action: input_number.set_value
                target: { entity_id: "{{ tilt_current_entity }}" }
                data: { value: "0" }

          # Cleanup
          - action: input_text.set_value
            target: { entity_id: "{{ sequence_id_entity }}" }
            data: { value: "" }
          - action: input_select.select_option
            target: { entity_id: "{{ state_entity }}" }
            data: { option: "idle" }
          - stop: "Tilt disabled - moved to 0%"

      # Berechne Delta und entscheide: Direkt oder Referenz-Methode
      - variables:
          delta_pct: "{{ tilt_target - tilt_current }}"
          # Richtung bestimmen: runter fÃ¼r 0%, hoch fÃ¼r target%
          ticks_for_delta: >
            {% if delta_pct > 0 %}
              {{ (delta_pct / 100.0 * tilt_ticks_open) | round(0) | int }}
            {% else %}
              {{ (delta_pct / 100.0 * tilt_ticks_close) | round(0) | int }}
            {% endif %}
          use_reference: "{{ (ticks_for_delta | abs) < min_motor_ticks }}"

      # Wenn keine Ã„nderung nÃ¶tig â†’ direkt beenden
      - if: "{{ delta_pct == 0 }}"
        then:
          - action: persistent_notification.create
            data:
              title: "â¸ï¸ Kein Tilt nÃ¶tig"
              message: "Current = Target = {{ tilt_target }}%"
          - stop: "Tilt already at target"

      # DEBUG: Tilt wird angewendet
      - action: persistent_notification.create
        data:
          title: "ðŸŽ¯ Tilt wird angewendet"
          message: |
            Delta: {{ delta_pct }}%
            Ticks needed: {{ ticks_for_delta }}
            Methode: {{ 'Referenz' if use_reference else 'Direkt' }}
            Position: {{ current_pos }} â†’ {{ current_pos + ticks_for_delta }}

      # Generiere Sequence ID
      - variables:
          seq_id: "{{ now().timestamp() | string }}"
      - action: input_text.set_value
        target: { entity_id: "{{ sequence_id_entity }}" }
        data: { value: "{{ seq_id }}" }

      - choose:
          # Direkt-Methode (Bewegung groÃŸ genug)
          - conditions: "{{ not use_reference }}"
            sequence:
              - action: input_select.select_option
                target: { entity_id: "{{ state_entity }}" }
                data: { option: "moving_tilt" }

              - action: mqtt.publish
                data:
                  topic: "logo/register/set/{{ register_target }}"
                  payload: "{{ current_pos + ticks_for_delta }}"

              - wait_template: "{{ states(status_sensor) | int(0) in [0,1] }}"
                timeout: "00:00:10"

              # PrÃ¼fe Sequence ID
              - if: "{{ states(sequence_id_entity) != seq_id }}"
                then:
                  - action: input_select.select_option
                    target: { entity_id: "{{ state_entity }}" }
                    data: { option: "idle" }
                  - stop: "Sequence interrupted"

              - action: input_number.set_value
                target: { entity_id: "{{ tilt_current_entity }}" }
                data: { value: "{{ tilt_target }}" }

          # Referenz-Methode (Bewegung zu klein)
          - conditions: "{{ use_reference }}"
            sequence:
              - action: input_select.select_option
                target: { entity_id: "{{ state_entity }}" }
                data: { option: "adjusting_tilt_ref" }

              # Schritt 1: Zu 0% Tilt (runter)
              - action: mqtt.publish
                data:
                  topic: "logo/register/set/{{ register_target }}"
                  payload: "{{ current_pos - tilt_ticks_close }}"

              - wait_template: "{{ states(status_sensor) | int(0) in [0,1] }}"
                timeout: "00:00:10"

              # PrÃ¼fe Sequence ID
              - if: "{{ states(sequence_id_entity) != seq_id }}"
                then:
                  - action: input_select.select_option
                    target: { entity_id: "{{ state_entity }}" }
                    data: { option: "idle" }
                  - stop: "Sequence interrupted at step 1"

              - delay: "00:00:0.5"

              # Schritt 2: Zu target% Tilt (hoch)
              - variables:
                  ticks_for_target: "{{ (tilt_target / 100.0 * tilt_ticks_open) | round(0) | int }}"
                  new_pos: "{{ states(position_sensor) | int(0) }}"

              - action: mqtt.publish
                data:
                  topic: "logo/register/set/{{ register_target }}"
                  payload: "{{ new_pos + ticks_for_target }}"

              - wait_template: "{{ states(status_sensor) | int(0) in [0,1] }}"
                timeout: "00:00:10"

              # PrÃ¼fe Sequence ID
              - if: "{{ states(sequence_id_entity) != seq_id }}"
                then:
                  - action: input_select.select_option
                    target: { entity_id: "{{ state_entity }}" }
                    data: { option: "idle" }
                  - stop: "Sequence interrupted at step 2"

              - action: input_number.set_value
                target: { entity_id: "{{ tilt_current_entity }}" }
                data: { value: "{{ tilt_target }}" }

      # Cleanup
      - action: input_text.set_value
        target: { entity_id: "{{ sequence_id_entity }}" }
        data: { value: "" }

      - action: input_select.select_option
        target: { entity_id: "{{ state_entity }}" }
        data: { option: "idle" }

  # -------------------------------------------------------
  # Langdruck (Coil halten, bis Button losgelassen / Timeout)
  # -------------------------------------------------------
  util_blinds_longpress:
    alias: "Blinds Â· Langdruck (Coil halten)"
    mode: restart
    fields:
      is_up:
        description: "true = Hoch-Langdruck, false = Runter-Langdruck"
      coil_up_value:
        description: "LOGO-Coilnummer fÃ¼r Hoch"
      coil_down_value:
        description: "LOGO-Coilnummer fÃ¼r Runter"
      pressed_button_entity_id:
        description: "Der gedrÃ¼ckte Button (binary_sensor.*)"

    sequence:
      - variables:
          coil_num: "{{ (coil_up_value if is_up else coil_down_value) }}"
      - action: mqtt.publish
        data:
          topic: "logo/coil/set/{{ coil_num }}"
          payload: "ON"
      - wait_template: "{{ is_state(pressed_button_entity_id, 'off') }}"
        timeout: "00:00:20" # Safety-Timeout
        continue_on_timeout: true
      - action: mqtt.publish
        data:
          topic: "logo/coil/set/{{ coil_num }}"
          payload: "OFF"

  # -------------------------------------------------------
  # ZÃ¤hllogik: Klick-Fenster starten + Klick zÃ¤hlen
  # -------------------------------------------------------
  util_blinds_counter_click:
    alias: "Blinds Â· ZÃ¤hllogik (Start/Increment)"
    mode: restart
    fields:
      is_up:
        description: "true = Hoch-Taste, false = Runter-Taste"
      counting_flag_entity_id:
        description: "input_boolean zum Markieren des laufenden ZÃ¤hlfensters"
      click_counter_entity_id:
        description: "counter.* fÃ¼r die Klickanzahl"
      last_direction_text_entity_id:
        description: "input_text fÃ¼r letzte Richtung ('up'/'down')"
      cover_entity_id:
        description: "cover.* (fÃ¼r open/close im Fenster)"
      floor_slug:
        description: "Stockwerk-Slug"
      room_slug:
        description: "Raum-Slug"
      state_entity_id:
        description: "input_select State Machine Entity"

    sequence:
      - variables:
          # Slugs als Strings sicherstellen
          floor_slug_str: "{{ floor_slug | string }}"
          room_slug_str: "{{ room_slug | string }}"

      # Fenster starten, falls nicht aktiv
      - if:
          - condition: template
            value_template: "{{ is_state(counting_flag_entity_id, 'off') }}"
        then:
          - action: input_boolean.turn_on
            target: { entity_id: "{{ counting_flag_entity_id }}" }
          - action: input_text.set_value
            target: { entity_id: "{{ last_direction_text_entity_id }}" }
            data: { value: "{{ 'up' if is_up else 'down' }}" }
          - action: script.turn_on
            target:
              entity_id: script.util_blinds_counter_window
            data:
              variables:
                counting_flag_entity_id: "{{ counting_flag_entity_id }}"
                click_counter_entity_id: "{{ click_counter_entity_id }}"
                last_direction_text_entity_id: "{{ last_direction_text_entity_id }}"
                cover_entity_id: "{{ cover_entity_id }}"
                floor_slug: "{{ floor_slug_str }}"
                room_slug: "{{ room_slug_str }}"
                state_entity_id: "{{ state_entity_id }}"

      # Klick zÃ¤hlen
      - action: counter.increment
        target: { entity_id: "{{ click_counter_entity_id }}" }

  # -------------------------------------------------------
  # ZÃ¤hlfenster (2s): wertet Klickzahl aus & fÃ¼hrt Aktionen aus
  # -------------------------------------------------------
  util_blinds_counter_window:
    alias: "Blinds Â· ZÃ¤hlfenster 2s (Auswertung)"
    mode: restart
    fields:
      counting_flag_entity_id:
        description: "input_boolean (Fenster aktiv?)"
      click_counter_entity_id:
        description: "counter.* (Klickanzahl)"
      last_direction_text_entity_id:
        description: "input_text ('up'/'down')"
      cover_entity_id:
        description: "cover.*"
      floor_slug:
        description: "Stockwerk-Slug"
      room_slug:
        description: "Raum-Slug"
      state_entity_id:
        description: "input_select State Machine Entity"

      # Optionale Overrides (Script-Entity-IDs) â€“ leer lassen, wenn ungenutzt
      on_up_3:
        description: "Script bei 3Ã— up (optional)"
      on_up_4:
        description: "Script bei 4Ã— up (optional)"
      on_down_2:
        description: "Script bei 2Ã— down (optional)"
      on_down_3:
        description: "Script bei 3Ã— down (optional)"
      on_down_4:
        description: "Script bei 4Ã— down (optional)"

    sequence:
      - delay: "00:00:02" # FensterlÃ¤nge
      - variables:
          # Slugs als Strings sicherstellen
          floor_slug_str: "{{ floor_slug | string }}"
          room_slug_str: "{{ room_slug | string }}"

          clicks: "{{ states(click_counter_entity_id) | int(0) }}"
          dir: "{{ states(last_direction_text_entity_id) }}"
          tilt_enabled_entity: "input_boolean.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_enabled"

      - choose:
          # ==== Hoch-Taste ====
          - conditions: "{{ dir == 'up' }}"
            sequence:
              - choose:
                  # 1Ã— up â†’ Ã¶ffnen + State setzen
                  - conditions: "{{ clicks == 1 }}"
                    sequence:
                      - action: input_select.select_option
                        target: { entity_id: "{{ state_entity_id }}" }
                        data: { option: "moving_user" }
                      - action: cover.open_cover
                        target: { entity_id: "{{ cover_entity_id }}" }

                  # 2Ã— up â†’ Tilt toggeln + sofort anwenden wenn idle
                  - conditions: "{{ clicks == 2 }}"
                    sequence:
                      - action: input_boolean.toggle
                        target: { entity_id: "{{ tilt_enabled_entity }}" }

                      # Sofort anwenden wenn idle (sonst wartet bis Fahrtende)
                      - if: "{{ states(state_entity_id) == 'idle' }}"
                        then:
                          - action: script.util_blinds_apply_tilt
                            data:
                              floor_slug: "{{ floor_slug_str }}"
                              room_slug: "{{ room_slug_str }}"

                  # 3Ã— up â†’ optionales Script
                  - conditions: "{{ clicks == 3 and (on_up_3 | default('') | string) != '' }}"
                    sequence:
                      - action: script.turn_on
                        target: { entity_id: "{{ on_up_3 }}" }

                  # 4Ã— up â†’ optionales Script
                  - conditions: "{{ clicks == 4 and (on_up_4 | default('') | string) != '' }}"
                    sequence:
                      - action: script.turn_on
                        target: { entity_id: "{{ on_up_4 }}" }

          # ==== Runter-Taste ====
          - conditions: "{{ dir == 'down' }}"
            sequence:
              - choose:
                  # 1Ã— down â†’ schlieÃŸen + State setzen
                  - conditions: "{{ clicks == 1 }}"
                    sequence:
                      - action: input_select.select_option
                        target: { entity_id: "{{ state_entity_id }}" }
                        data: { option: "moving_user" }
                      - action: cover.close_cover
                        target: { entity_id: "{{ cover_entity_id }}" }

                  # 2Ã—/3Ã—/4Ã— down â†’ jeweils optionales Script
                  - conditions: "{{ clicks == 2 and (on_down_2 | default('') | string) != '' }}"
                    sequence:
                      - action: script.turn_on
                        target: { entity_id: "{{ on_down_2 }}" }
                  - conditions: "{{ clicks == 3 and (on_down_3 | default('') | string) != '' }}"
                    sequence:
                      - action: script.turn_on
                        target: { entity_id: "{{ on_down_3 }}" }
                  - conditions: "{{ clicks == 4 and (on_down_4 | default('') | string) != '' }}"
                    sequence:
                      - action: script.turn_on
                        target: { entity_id: "{{ on_down_4 }}" }

      # Fenster beenden & Counter zurÃ¼cksetzen
      - action: input_boolean.turn_off
        target: { entity_id: "{{ counting_flag_entity_id }}" }
      - action: counter.reset
        target: { entity_id: "{{ click_counter_entity_id }}" }
