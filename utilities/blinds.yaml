# =========================================================
# README · Blinds/LOGO Utility-Skripte (konsistente Benennung)
# ---------------------------------------------------------
# Enthaltene Skripte
# - util_blinds_tilt_step_ticks_dir
#     Adaptiver Tilt-Schritt in Ticks, abhängig von:
#       • letzter Bewegungsrichtung (2=closing/runter, 3=opening/hoch)
#       • aktueller Position (Interpolation zwischen „unten“- und „oben“-Schritt)
#       • je Richtung separat kalibrierbaren Schrittgrößen (Ticks)
#
# - util_blinds_longpress
#     Hält die passende LOGO-Coil (hoch/runter), bis der Button losgelassen wird
#     oder ein Safety-Timeout greift.
#
# - util_blinds_counter_click + util_blinds_counter_window
#     Klickzähler (Fenster 2s): 1× open/close, 2× Tilt-Flag toggle, 3/4× optional.
#
# Namenskonvention
# - *_entity_id  … erwartet eine Entity-ID (z. B. cover.*, input_boolean.*, counter.*)
# - *_value      … reine Werte (Zahlen)
# - *_number_entity_id … input_number-Entität
#
# MQTT (erwartete Topics)
# - logo/register/set/<number>  (payload: Ticks-Ziel oder „10000“)
# - logo/coil/set/<number>      (payload: "ON"/"OFF")
# =========================================================

script:
  # -------------------------------------------------------
  # Tilt anwenden (neues System mit Referenz-Methode)
  # -------------------------------------------------------
  util_blinds_apply_tilt:
    alias: "Blinds · Tilt anwenden"
    mode: queued
    max: 10
    fields:
      floor_slug:
        description: "Stockwerk-Slug (z. B. '0')"
      room_slug:
        description: "Raum-Slug (z. B. 'living_room_west')"

    sequence:
      - variables:
          # Slugs als Strings sicherstellen
          floor_slug_str: "{{ floor_slug | string }}"
          room_slug_str: "{{ room_slug | string }}"

          # Entitäten ableiten
          state_entity: "input_select.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_state"
          sequence_id_entity: "input_text.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_sequence_id"
          tilt_enabled_entity: "input_boolean.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_enabled"
          tilt_current_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_current"
          tilt_target_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_target"
          tilt_ticks_close_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_ticks_close"
          tilt_ticks_open_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_ticks_open"
          min_motor_ticks_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_min_motor_ticks"
          position_sensor: "sensor.mosquitto_broker_mqtt_logo_hr_104_position_raw"
          register_target_entity: "input_number.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_logo_register_target"
          status_sensor: "sensor.mosquitto_broker_mqtt_logo_hr_104_status"

          # Werte lesen
          tilt_enabled: "{{ is_state(tilt_enabled_entity, 'on') }}"
          tilt_current: "{{ states(tilt_current_entity) | int(0) }}"
          tilt_target: "{{ states(tilt_target_entity) | int(75) }}"
          tilt_ticks_close: "{{ states(tilt_ticks_close_entity) | int(14) }}"
          tilt_ticks_open: "{{ states(tilt_ticks_open_entity) | int(15) }}"
          min_motor_ticks: "{{ states(min_motor_ticks_entity) | int(5) }}"
          current_pos: "{{ states(position_sensor) | int(0) }}"
          register_target: "{{ states(register_target_entity) | int(535) }}"

      # Prüfen ob Tilt überhaupt aktiv
      - if: "{{ not tilt_enabled }}"
        then:
          - stop: "Tilt not enabled"

      # Berechne Delta und entscheide: Direkt oder Referenz-Methode
      - variables:
          delta_pct: "{{ tilt_target - tilt_current }}"
          # Richtung bestimmen: runter für 0%, hoch für target%
          ticks_for_delta: >
            {% if delta_pct > 0 %}
              {{ (delta_pct / 100.0 * tilt_ticks_open) | round(0) | int }}
            {% else %}
              {{ (delta_pct / 100.0 * tilt_ticks_close) | round(0) | int }}
            {% endif %}
          use_reference: "{{ (ticks_for_delta | abs) < min_motor_ticks }}"

      # Generiere Sequence ID
      - variables:
          seq_id: "{{ now().timestamp() | string }}"
      - action: input_text.set_value
        target: { entity_id: "{{ sequence_id_entity }}" }
        data: { value: "{{ seq_id }}" }

      - choose:
          # Direkt-Methode (Bewegung groß genug)
          - conditions: "{{ not use_reference and delta_pct != 0 }}"
            sequence:
              - action: input_select.select_option
                target: { entity_id: "{{ state_entity }}" }
                data: { option: "moving_tilt" }

              - action: mqtt.publish
                data:
                  topic: "logo/register/set/{{ register_target }}"
                  payload: "{{ current_pos + ticks_for_delta }}"

              - wait_template: "{{ states(status_sensor) | int(0) in [0,1] }}"
                timeout: "00:00:10"

              # Prüfe Sequence ID
              - if: "{{ states(sequence_id_entity) != seq_id }}"
                then:
                  - stop: "Sequence interrupted"

              - action: input_number.set_value
                target: { entity_id: "{{ tilt_current_entity }}" }
                data: { value: "{{ tilt_target }}" }

          # Referenz-Methode (Bewegung zu klein)
          - conditions: "{{ use_reference and delta_pct != 0 }}"
            sequence:
              - action: input_select.select_option
                target: { entity_id: "{{ state_entity }}" }
                data: { option: "adjusting_tilt_ref" }

              # Schritt 1: Zu 0% Tilt (runter)
              - action: mqtt.publish
                data:
                  topic: "logo/register/set/{{ register_target }}"
                  payload: "{{ current_pos - tilt_ticks_close }}"

              - wait_template: "{{ states(status_sensor) | int(0) in [0,1] }}"
                timeout: "00:00:10"

              # Prüfe Sequence ID
              - if: "{{ states(sequence_id_entity) != seq_id }}"
                then:
                  - stop: "Sequence interrupted at step 1"

              - delay: "00:00:0.5"

              # Schritt 2: Zu target% Tilt (hoch)
              - variables:
                  ticks_for_target: "{{ (tilt_target / 100.0 * tilt_ticks_open) | round(0) | int }}"
                  new_pos: "{{ states(position_sensor) | int(0) }}"

              - action: mqtt.publish
                data:
                  topic: "logo/register/set/{{ register_target }}"
                  payload: "{{ new_pos + ticks_for_target }}"

              - wait_template: "{{ states(status_sensor) | int(0) in [0,1] }}"
                timeout: "00:00:10"

              # Prüfe Sequence ID
              - if: "{{ states(sequence_id_entity) != seq_id }}"
                then:
                  - stop: "Sequence interrupted at step 2"

              - action: input_number.set_value
                target: { entity_id: "{{ tilt_current_entity }}" }
                data: { value: "{{ tilt_target }}" }

      # Cleanup
      - action: input_text.set_value
        target: { entity_id: "{{ sequence_id_entity }}" }
        data: { value: "" }

      - action: input_select.select_option
        target: { entity_id: "{{ state_entity }}" }
        data: { option: "idle" }

  # -------------------------------------------------------
  # Langdruck (Coil halten, bis Button losgelassen / Timeout)
  # -------------------------------------------------------
  util_blinds_longpress:
    alias: "Blinds · Langdruck (Coil halten)"
    mode: restart
    fields:
      is_up:
        description: "true = Hoch-Langdruck, false = Runter-Langdruck"
      coil_up_value:
        description: "LOGO-Coilnummer für Hoch"
      coil_down_value:
        description: "LOGO-Coilnummer für Runter"
      pressed_button_entity_id:
        description: "Der gedrückte Button (binary_sensor.*)"

    sequence:
      - variables:
          coil_num: "{{ (coil_up_value if is_up else coil_down_value) }}"
      - action: mqtt.publish
        data:
          topic: "logo/coil/set/{{ coil_num }}"
          payload: "ON"
      - wait_template: "{{ is_state(pressed_button_entity_id, 'off') }}"
        timeout: "00:00:20" # Safety-Timeout
        continue_on_timeout: true
      - action: mqtt.publish
        data:
          topic: "logo/coil/set/{{ coil_num }}"
          payload: "OFF"

  # -------------------------------------------------------
  # Zähllogik: Klick-Fenster starten + Klick zählen
  # -------------------------------------------------------
  util_blinds_counter_click:
    alias: "Blinds · Zähllogik (Start/Increment)"
    mode: restart
    fields:
      is_up:
        description: "true = Hoch-Taste, false = Runter-Taste"
      counting_flag_entity_id:
        description: "input_boolean zum Markieren des laufenden Zählfensters"
      click_counter_entity_id:
        description: "counter.* für die Klickanzahl"
      last_direction_text_entity_id:
        description: "input_text für letzte Richtung ('up'/'down')"
      cover_entity_id:
        description: "cover.* (für open/close im Fenster)"
      floor_slug:
        description: "Stockwerk-Slug"
      room_slug:
        description: "Raum-Slug"

    sequence:
      - variables:
          # Slugs als Strings sicherstellen
          floor_slug_str: "{{ floor_slug | string }}"
          room_slug_str: "{{ room_slug | string }}"

      # Fenster starten, falls nicht aktiv
      - if:
          - condition: template
            value_template: "{{ is_state(counting_flag_entity_id, 'off') }}"
        then:
          - action: input_boolean.turn_on
            target: { entity_id: "{{ counting_flag_entity_id }}" }
          - action: input_text.set_value
            target: { entity_id: "{{ last_direction_text_entity_id }}" }
            data: { value: "{{ 'up' if is_up else 'down' }}" }
          - action: script.turn_on
            target:
              entity_id: script.util_blinds_counter_window
            data:
              variables:
                counting_flag_entity_id: "{{ counting_flag_entity_id }}"
                click_counter_entity_id: "{{ click_counter_entity_id }}"
                last_direction_text_entity_id: "{{ last_direction_text_entity_id }}"
                cover_entity_id: "{{ cover_entity_id }}"
                floor_slug: "{{ floor_slug_str }}"
                room_slug: "{{ room_slug_str }}"

      # Klick zählen
      - action: counter.increment
        target: { entity_id: "{{ click_counter_entity_id }}" }

  # -------------------------------------------------------
  # Zählfenster (2s): wertet Klickzahl aus & führt Aktionen aus
  # -------------------------------------------------------
  util_blinds_counter_window:
    alias: "Blinds · Zählfenster 2s (Auswertung)"
    mode: restart
    fields:
      counting_flag_entity_id:
        description: "input_boolean (Fenster aktiv?)"
      click_counter_entity_id:
        description: "counter.* (Klickanzahl)"
      last_direction_text_entity_id:
        description: "input_text ('up'/'down')"
      cover_entity_id:
        description: "cover.*"
      floor_slug:
        description: "Stockwerk-Slug"
      room_slug:
        description: "Raum-Slug"

      # Optionale Overrides (Script-Entity-IDs) – leer lassen, wenn ungenutzt
      on_up_3:
        description: "Script bei 3× up (optional)"
      on_up_4:
        description: "Script bei 4× up (optional)"
      on_down_2:
        description: "Script bei 2× down (optional)"
      on_down_3:
        description: "Script bei 3× down (optional)"
      on_down_4:
        description: "Script bei 4× down (optional)"

    sequence:
      - delay: "00:00:02" # Fensterlänge
      - variables:
          # Slugs als Strings sicherstellen
          floor_slug_str: "{{ floor_slug | string }}"
          room_slug_str: "{{ room_slug | string }}"

          clicks: "{{ states(click_counter_entity_id) | int(0) }}"
          dir: "{{ states(last_direction_text_entity_id) }}"
          tilt_enabled_entity: "input_boolean.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_tilt_enabled"
          state_entity: "input_select.blinds_{{ floor_slug_str }}_{{ room_slug_str }}_state"

      - choose:
          # ==== Hoch-Taste ====
          - conditions: "{{ dir == 'up' }}"
            sequence:
              - choose:
                  # 1× up → öffnen
                  - conditions: "{{ clicks == 1 }}"
                    sequence:
                      - action: cover.open_cover
                        target: { entity_id: "{{ cover_entity_id }}" }

                  # 2× up → Tilt toggeln + sofort anwenden wenn idle
                  - conditions: "{{ clicks == 2 }}"
                    sequence:
                      - action: input_boolean.toggle
                        target: { entity_id: "{{ tilt_enabled_entity }}" }

                      # Sofort anwenden wenn idle (sonst wartet bis Fahrtende)
                      - if: "{{ states(state_entity) == 'idle' }}"
                        then:
                          - action: script.util_blinds_apply_tilt
                            data:
                              floor_slug: "{{ floor_slug_str }}"
                              room_slug: "{{ room_slug_str }}"

                  # 3× up → optionales Script
                  - conditions: "{{ clicks == 3 and (on_up_3 | default('') | string) != '' }}"
                    sequence:
                      - action: script.turn_on
                        target: { entity_id: "{{ on_up_3 }}" }

                  # 4× up → optionales Script
                  - conditions: "{{ clicks == 4 and (on_up_4 | default('') | string) != '' }}"
                    sequence:
                      - action: script.turn_on
                        target: { entity_id: "{{ on_up_4 }}" }

          # ==== Runter-Taste ====
          - conditions: "{{ dir == 'down' }}"
            sequence:
              - choose:
                  # 1× down → schließen
                  - conditions: "{{ clicks == 1 }}"
                    sequence:
                      - action: cover.close_cover
                        target: { entity_id: "{{ cover_entity_id }}" }

                  # 2×/3×/4× down → jeweils optionales Script
                  - conditions: "{{ clicks == 2 and (on_down_2 | default('') | string) != '' }}"
                    sequence:
                      - action: script.turn_on
                        target: { entity_id: "{{ on_down_2 }}" }
                  - conditions: "{{ clicks == 3 and (on_down_3 | default('') | string) != '' }}"
                    sequence:
                      - action: script.turn_on
                        target: { entity_id: "{{ on_down_3 }}" }
                  - conditions: "{{ clicks == 4 and (on_down_4 | default('') | string) != '' }}"
                    sequence:
                      - action: script.turn_on
                        target: { entity_id: "{{ on_down_4 }}" }

      # Fenster beenden & Counter zurücksetzen
      - action: input_boolean.turn_off
        target: { entity_id: "{{ counting_flag_entity_id }}" }
      - action: counter.reset
        target: { entity_id: "{{ click_counter_entity_id }}" }
